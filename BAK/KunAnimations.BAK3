//=============================================================================
// KunAnimations.js
//=============================================================================
/*:
 * @filename KunAnimations.js
 * @plugindesc Kun Interactive Picture Animations - Animate pictures with custom framesets and commands, now featuring an interactive framework to click over specific hotspots depending on the frameset running.
 * @version 2.00
 * @author KUN
 * @target MC | MZ
 * 
 * @help
 * 
 * COMMANDS:
 * 
 *      KunAnimations start animation-name [setName]
 *          Switch animation frameset setName for animation-name
 * 
 *      KunAnimations set animation-name [setName] [wait frames:frame_offset]
 *          Switch animation frameset setName for animation-name
 *          wait frames will pause the interpreter for the defined frames before going on
 *          frame_offset will add random frames from [frames] to [frames + frame_offset]
 * 
 *      KunAnimations reset animation-name [replay]
 *          Resets the given animation
 *          Restarts the controller if replay is required
 * 
 *      KunAnimations fps animation-name [fps] [import]
 *          Set custom frames per second for the playing animation-name. Define import to use a Game Variable to grab the fps from
 * 
 *      KunAnimations pause animation-name
 *          Pause animation-name if playing
 * 
 *      KunAnimations resume animation-name
 *          Resume animation-name if paused
 * 
 *      KunAnimations target [random]
 *          Update to the next target in the list of touched spots
 * 
 *      KunAnimations mode [capture|touch|disabled]
 *          Set the mouse interactive mode. Set touch to activate the interactive events. Set capture to describe hotspot areas in the console (requires debug mode on). Set disable to turn off the event listener.
 * 
 *      KunAnimations clear [targets | alias]
 *          Clear the current target queue
 *          Clear targets or defined aliases
 * 
 *      KunAnimations alias [alias_name] [animation_name]
 *          Create an alias for a specific animation controller to ease picture swapping with the same tags
 * 
 *      KunAnimations play [sound_bank_name] [wait_seconds] [random_elapsed_seconds]
 *          Play a sound bank selection by name
 *          Set wait seconds to include a time waiting pause before running the next events
 *          Add random elapsed seconds to define a randomized timespan
 * 
 *      KunAnimations interruption [on|off]
 *          Allow a sound bank selection to interrupt other Sound Effects playing by MEdia Player
 *          Activated by default for those sound banks marked with Allow SE interruption
 * 
 *      KunAnimations wait [elapsed_seconds] [random_elapsed_seconds]
 *          Wait for elapsed seconds before running the next routines in the event editor
 *          Add random elapsed seconds to define a randomized timespan
 * 
 * 
 * HIERARCHY:
 * 
 *  -> Scene
 *  ----> AnimationLayer
 *  --------> TouchSpot
 * 
 *  - Animation Controllers
 *    defined by the Selected Picture File.
 *    Here you can setup the columns and rows, to properly display the frames.
 * 
 *  - Animation Frameset Groups
 *    A list of frames to play, with a custom FPS, behavior and looping iterations.
 * 
 *  - Touch Spots
 *    Every frameset animates a list of frames, but you can define on these a list of specific spots
 *    to click and cause a reaction, update a Game Variable, play a custom sound effect,
 *    and change to another specific frameset.
 * 
 * 
 * @param debug
 * @text Debug Level
 * @desc Show debug info. Activate Trace Log to detail the imports and exports of data.
 * @type select
 * @option TraceLog
 * @value 2
 * @option Enabled
 * @value 1
 * @option Disabled
 * @value 0
 * @default 0
 * 
 * @param defaultFPS
 * @text Master Frame Time
 * @desc default frame time
 * @type number
 * @min 1
 * @default 10
 * 
 * @param touchVarCounter
 * @text Touch Counter Variable
 * @desc This variable handles the counter of enqueued interactions performed by the player
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchVarLimit
 * @parent touchVar
 * @text Touch Limit Variable
 * @desc How many interactions can be saved in the queue. Can be updated in game to increase the touch events.
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchMode
 * @parent touchVar
 * @text Touch Mode Switch
 * @desc Use it to keep control of the interactive mode in the event editor. Use KunAnimations mode touch | disable to change it.
 * @type switch
 * @default 0
 * 
 * @param touchX
 * @text Touch X Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchY
 * @text Touch Y Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchSfx
 * @text Default Touch SE
 * @desc Define a default sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param cancelSfx
 * @text Don't Touch SE
 * @desc Define a no touch sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param animPacks
 * @text Extended Animation Packs
 * @desc Requires KunAnimationPacks Plugin to extend the animation collections to import
 * @type number
 * @min 0
 * @default 0
 * 
 * @param scenes
 * @type struct<Scene>[]
 * @text Animation Scenes
 * @desc Define the DataBase of Animation Scenes (keep it clean and easy!!)
 * 
 * @param controllers
 * @type struct<Scene>[]
 * @text Backwards compatibility (OBSOLETE)
 * @desc Move all this content to Animation Scenes(scenes)
 * 
 */
/*~struct~Scene:
 *
 * @param source
 * @text Source Picture Pack
 * @desc Add one or more source pictures with the same frameset columns and rows, to use with the same animation rules. Duplicated pictures will be discarded.
 * @type file[]
 * @require 1
 * @dir img/pictures/
 * 
 * @param cols
 * @text Columns
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param rows
 * @text Rows
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param fps
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param framesets
 * @type struct<FrameSet>[]
 * @text Animations
 * @desc Animation Frameset Collection
 * 
 * @param hotspots
 * @type struct<HotSpot>[]
 * @text Event Hotspots
 * @desc Add the interactive spots here
 * @default []
 * 
 * @param soundBankPrefix
 * @type text[]
 * @text Sound Bank Prefix
 * @desc Add here the sound bank prefix for each picture souce when required
 * 
 * @param actions
 * @type struct<Action>[]
 * @text Start Actions
 * @desc Run these actions on start
 * @default []
 */
/*~struct~FrameSet:
 * 
 * @param name
 * @text Name
 * @type text
 * @default new-animation
 * 
 * @param frames
 * @text FrameSet
 * @type number[]
 * @min 0
 * @desc List of frames to play in this animation
 * 
 * @param type
 * @parent frames
 * @text Animation Type
 * @type select
 * @option Forward (default)
 * @value forward
 * @option Reverse
 * @value reverse
 * @option Ping-Pong
 * @value ping-pong
 * @option Static
 * @value static
 * @default forward
 * 
 * @param fps
 * @parent frames
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param loops
 * @parent frames
 * @type number
 * @text Loops
 * @desc number of times the animation will play before switching to the next animation. Leave it to 0 for endless loops (no next animation)
 * @default 0
 * 
 * @param next
 * @parent frames
 * @text Next Layer
 * @type text[]
 * @desc Define the next frameset to call. If more than one specified, they will be randomly called
 * 
 * @param offsetX
 * @text X Offset
 * @type number
 * @default 0
 * 
 * @param offsetY
 * @text Y Offset
 * @type number
 * @default 0
 * 
 * @param spots
 * @type struct<TouchSpot>[]
 * @text Touch Spots
 * @desc Interactive Spots to fire events
 * @default []
 * 
 * @param sounds
 * @text Sounds
 * @desc Play one of these sound collections each time this animation is played. Requires KunSoundPacks.
 * @type text[]
 * @default []
 * 
 * @param conditions
 * @type struct<Condition>[]
 * @text Conditions
 * @desc Run this animation when meeting these conditions
 * @default []
 */
/*~struct~Action:
 * @param var
 * @type variable
 * @text Game Variable
 * @desc define a game variable to update with this action
 * @min 0
 * @default 0
 * 
 * @param op
 * @text Operator
 * @desc Operation type to run on the Game Variable
 * @type select
 * @option Add
 * @value add
 * @option Sub
 * @value sub
 * @option Set
 * @value set
 * @default set
 * 
 * @param val
 * @text Value
 * @desc Value to update the game variable with
 * @type number[]
 * @min 0
 * @default ["0"]
 * 
 * @param switchOn
 * @type switch[]
 * @text Game Switch On
 * @desc define a list of game switches to activate when running this animation layer
 * @min 0
 * @default []
 * 
 * @param SwitchOff
 * @type switch[]
 * @text Game Switch Off
 * @desc define a list of game switches to disable when running this animation layer
 * @min 0
 * @default []
 * 
 * @param conditions
 * @type struct<Condition>[]
 * @text Conditions
 * @desc Run this action when meeting these conditions
 * @default []
 */
/*~struct~Condition:
 *
 * @param sw
 * @type switch
 * @text Game Switch
 * @desc define a game switch to check for this condition
 * @default 0
 *
 * @param var
 * @type variable
 * @text Game Variable
 * @desc define a game variable to check for this condition
 * @min 0
 * @default 0
 * 
 * @param op
 * @text Operator
 * @desc Select the type of operation to cast over the value for this Game Variable
 * @type select
 * @option Greater
 * @value greater
 * @option Greater or equal
 * @value greater_equal
 * @option Equal
 * @value equal
 * @option Less or equal
 * @value less_equal
 * @option Less
 * @value less
 * 
 * @param val
 * @type number
 * @text Value Range
 * @desc Operate with this value
 * @min 0
 * @default 0
 */
/*~struct~TouchSpot:
 * 
 * @param name
 * @text Name
 * @desc Bind here a HotSpot when hitting a specific area in the animation.
 * @type text
 * @default touch-here
 * 
 * @param trigger
 * @text On Click
 * @type select
 * @desc Define the behaviour on touching this HotSpot
 * @option Instant Run
 * @value instant
 * @option Queue
 * @value queue
 * @option Next Frame
 * @value frame
 * @option Ignore
 * @value ignore
 * @default queue
 * 
 * @param next
 * @text Switch Animation
 * @desc Jump to any of these animations on touched (allow mrandom options when more than 1)
 * @type text[]
 * @default []
 * 
 */
/*~struct~HotSpot:
 * 
 * @param name
 * @text Name
 * @type text
 * @default touch-here
 * 
 * @param x1
 * @text X1
 * @type number
 * @min 0
 * @desc X origin coordinate
 * 
 * @param y1
 * @text Y1
 * @type number
 * @min 0
 * @desc Y origin coordinate
 * 
 * @param x2
 * @text X2
 * @type number
 * @min 0
 * @desc X destination coordinate
 * 
 * @param y2
 * @text Y2
 * @type number
 * @min 0
 * @desc Y destination coordinate
 * 
 * @param sfx
 * @text Touch Audio SFX
 * @desc Define a specific sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param actions
 * @type struct<Action>[]
 * @text Actions
 * @desc Run these Actions on activating this HotSpot
 * @default []
 *  
 * @param conditions
 * @type struct<Condition>[]
 * @text Conditions
 * @desc Enable this HotSpot when meeting these conditions
 * @default []
 */


//const { count } = require('console');

/**
 * @description KUN Modules
 * @type KUN
 */
//var KUN = KUN || {};

/**
 * 
 * @returns 
 */
function KunSceneManager() {
    throw `${this.constructor.name} is a Static Class`;
}
/**
 * 
 * @returns KunSceneManager
 */
KunSceneManager.Initialize = function(){

    var parameters = KunSceneImporter.PluginData();
    //var parameters = this.PluginParameters();

    this._debug =  parameters.debug;
    this._fps = parameters.defaultFPS;
    this._touchVar = parameters.touchVarCounter;
    this._limitVar = parameters.touchVarLimit;
    this._touchMode = parameters.touchMode;

    this._varX = parameters.touchX;
    this._varY = parameters.touchY;
    this._sfx = {
        'touch': parameters.touchSfx || '',
        'cancel': parameters.cancelSfx || '',
    };


    this._mode = KunSceneManager.Mode().Disabled;
    this._soundBanks = {};
    this._scenes = {};
    //this._overrides = {};
    this._alias = {};
    this._targets = [];

    this._breakInterrupt = false;
    this._animationPacks = parameters.animPacks;

    KunSceneImporter.ImportScenes( parameters.controllers );

    return this;
};
/**
 * @returns Object
 */
KunSceneManager.DebugMode = function(){
    return {
        'Disabled':0,
        'Enabled': 1,
        'TraceLog': 2,
    };
};
/**
 * 
 * @param {Boolean} stop 
 */
KunSceneManager.stopInterruption = function( stop ){
    this._breakInterrupt = typeof stop === 'boolean' && stop;
    return this.canInterrupt();
};
/**
 * @returns Number
 */
KunSceneManager.animationPacks = function(){
    return this._animationPacks;
};
/**
 * @returns Boolean
 */
KunSceneManager.canInterrupt = function(){
    return !this._breakInterrupt;
};
    /**
     * @returns Boolean
     */
    KunSceneManager.debug = function( level ){
        if( typeof level === 'number' && level > 0 ){
            return this._debug >= level;
        }
        return this._debug > KunSceneManager.DebugMode().Disabled;
    };
    /**
     * @param {String} bank 
     * @param {Number} round
     * @returns KunSceneManager
     */
    KunSceneManager.playSound = function( collection , round ){
        if( typeof KunSoundPacks === 'function' ){
            //KunSceneManager.DebugLog( `Playing Sound Collection: ${collection}` );
            KunSoundPacks.play( collection , round );
        }
        return this;
    };
    /**
     * 
     * @param {String} alias 
     * @param {String} original 
     * @returns KunSceneManager
     */
    KunSceneManager.setAlias = function( alias , original ){
        this._alias[alias] = original;
        return this;
    };
    /**
     * @param {String} alias 
     * @returns String
     */
    KunSceneManager.getAlias = function( alias ){
        return this._alias.hasOwnProperty(alias) ? this._alias[alias] : alias;
    }
    /**
     * 
     * @returns KunSceneManager
     */
    KunSceneManager.clearAlias = function(){
        this._alias = {};
        return this;
    };
    /**
     * @param {String} mode 
     * @returns KunSceneManager
     */
    KunSceneManager.setMode = function( mode ){
        this._mode = mode;
        switch( this._mode ){
            case KunSceneManager.Mode().Capture:
            case KunSceneManager.Mode().Touch:
                this.unlock(true);
                break;
            case KunSceneManager.Mode().Disabled:
            default:
                this.clearTargets().lock();
                break;
        }
        return this;
    };
    /**
     * @returns Object
     */
    KunSceneManager.dump = function(){
        return this;
    }
    /**
     * @returns String
     */
    KunSceneManager.sfx = function( name ){
        return typeof name === 'string' && name.length && this._sfx.hasOwnProperty(name) ? this._sfx[name] : this._sfx.touch;
    };
    /**
     * @returns Number
     */
    KunSceneManager.limit = function(){
        return this._limitVar > 0 ? $gameVariables.value( this._limitVar ) : 1;
    };
    /**
     * @param {Boolean} unlock
     * @returns KunSceneManager
     */
    KunSceneManager.unlock = function( unlock ){
        if( this._touchMode ){
            $gameSwitches.setValue( this._touchMode, typeof unlock === 'boolean' && unlock );
        }
        return this;
    };
    /**
     * @returns KunSceneManager
     */
    KunSceneManager.lock = function( ){
        return this.unlock(false);
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.locked = function(){
        return this._mode === KunSceneManager.Mode().Disabled;
        return this._touchMode > 0 && !$gameSwitches.value(this._touchMode);
    };
    /**
     * @param {String} name 
     * @returns Object {X,Y}
     */
    KunSceneManager.offset = function( name ){
        var picture = this.get(name);
        if( picture !== null ){
            var layer = picture.current();
            if( layer !== null ){
                return {
                    'x':layer.offsetX(),
                    'y':layer.offsetY()
                };
            }
        }
        return {'x':0,'y':0};
    };
    /**
     * @param {String} picture
     * @param {String} spot
     * @param {Number} x 
     * @param {Number} y 
     * @returns Boolean
     */
    KunSceneManager.enqueue = function( picture , spot , x , y ){
        if( this.targets().length < this.limit() ){
            this.targets().push({
                'scene':picture,
                'spot': spot,
                'x':x,
                'y':y,
            });
            this.updateTouchPoints( this.countTargets()).playFx();
            return true;
        }
        else{
            KunSceneManager.PlayFX(this.sfx('cancel'));
        }
        return false;
    };
    /**
     * @returns Array
     */
    KunSceneManager.targets = function(){
        return this._targets;
    };
    /**
     * @returns Number
     */
    KunSceneManager.countTargets = function(){
        return this._targets.length;
    }
    /**
     * 
     * @returns KunSceneManager
     */
    KunSceneManager.clearTargets = function(){
        this._targets = [];
        return this.updateTouchPoints();
    };
    /**
     * @param {Boolean} random 
     * @returns Object
     */
    KunSceneManager.nextSpot = function( random ){
        var spot = typeof random === 'boolean' && random && this.countTargets() > 1 ?
            this.targets().splice( Math.floor(Math.random() * this.countTargets( ) ), 1) :
            this.targets().shift();
        return Array.isArray(spot) ? spot[0] : spot;
    };
    /**
     * @param {Boolean} random
     * @returns KunSceneManager
     */
    KunSceneManager.target = function( random ){
        if(this.countTargets()){
            var touch = this.nextSpot( random );
            //console.log(spot);
            var scene = this.get(touch.scene);
            if( scene !== null ){
                var fs = scene.current();
                if( fs !== null ){
                        var target = fs.getSpot(touch.spot);
                        if( target !== null ){
                            target.update();
                            //export X and Y positions
                            this.exportPosition( touch.x , touch.y );
                            //jump to next frameset (if any)
                            scene.changeLayer( scene.selectLayer( target.nextLayers() , true ) , true );
                            //this.selectLayer( this.current().next() , true )
                            //scene.changeLayer( target.next() , true );
                        }
                }
                else{
                    KunSceneManager.DebugLog(`Invalid FrameSet ${touch.spot}`);    
                }
            }
            else{
                KunSceneManager.DebugLog(`Invalid Controller ${touch.scene}`);
            }
        }    
        return this.updateTouchPoints(this.countTargets());
    };
    /**
     * @param {String} picture 
     * @returns KunSceneManager
     */
    KunSceneManager.randomTarget = function( picture ){
        var scene = this.get(picture);
        if( scene !== null ){
            var layer = scene.current();
            if( layer !== null ){
                var spot = layer.randomSpot();
                if( spot !== null ){
                    var pos = spot.generatePosition( );
                    this.exportPosition( pos.x , pos.y );
                }
            }
        }
        return this;
    };
    /**
     * @param {Number} x 
     * @param {Number} y 
     * @returns KunSceneManager
     */
    KunSceneManager.exportPosition = function( x  , y ){
        if( this._varX > 0 ){
            $gameVariables.setValue(this._varX,x);
        }
        if( this._varY > 0 ){
            $gameVariables.setValue(this._varY,y);
        }
        //KunSceneManager.DebugLog(`Event Clicked on ${x},${y}`);
        return this;
    };
    /**
     * @param {Number} counter 
     * @returns KunSceneManager
     */
    KunSceneManager.updateTouchPoints = function( counter ){
        if( this._touchVar > 0 ){
            $gameVariables.setValue(this._touchVar , counter  || 0 );
        }
        return this;
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.canCapture = function(){
        return this._mode === KunSceneManager.Mode().Capture;
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.canTouch = function(){
        return this._mode === KunSceneManager.Mode().Touch && !this.locked();
    };
    /**
     * @returns String
     */
    KunSceneManager.mode = function(){
        return this._mode;
    };
    /**
     * @returns Number
     */
    KunSceneManager.defaultFps = function(){
        return this._fps;
    };
    /**
     * @returns Array | Object
     */
    KunSceneManager.scenes = function( list ){
        return typeof list === 'boolean' && list ? Object.values(this._scenes) : this._scenes;
    };
    /**
     * @returns Array
     */
    KunSceneManager.list = function( ){
        return Object.keys( this._scenes );
    };
    /**
     * @param {KunAnimationScene} controller 
     * @returns KunSceneManager
     */
    KunSceneManager.addScene = function( controller ){
        if( controller instanceof KunAnimationScene && !this.has(controller.name()) ){
            this._scenes[controller.name()] = controller;
        }
        return this;
    };
    /**
     * @param {String} name 
     * @returns Boolean
     */
    KunSceneManager.has = function( name ){
        return this._scenes.hasOwnProperty( name );
    }
    /**
     * @param {String} name 
     * @returns Boolean
     */
    KunSceneManager.isPlaying = function( name ){
        return this.has( name ) && this.get( name ).playing();
    };
    /**
     * @returns Array
     */
    KunSceneManager.controllers = function( list ){
        return typeof list === 'boolean' && list ? Object.values( this._scenes ) : this._scenes;
    };
    /**
     * @param {String} pictureName 
     * @returns {KunAnimationScene}
     */
    KunSceneManager.get = function( pictureName ){
        return this.has( pictureName ) ? this._scenes[pictureName] : null;
    }
    /**
     * @param {String} pictureName 
     * @returns {KunAnimationScene}
     */
    KunSceneManager.scene = function( pictureName ){
        return this.has( pictureName ) ? this._scenes[pictureName] : KunAnimationScene.INVALID;
    }
    /**
     * @param {String} pictureName 
     * @returns {KunSceneManager}
     */
    KunSceneManager.stop = function( pictureName ){
        return this;
    };
    /**
     * @param {String} picturename 
     * @param {Boolean} replay
     * @returns KunSceneManager
     */
    KunSceneManager.reset = function( picturename , replay  ){
        if( this.has( picturename)){
            this.get(picturename).first().reset( typeof replay === 'boolean' && replay );
        }
        return this;
    }
    /**
     * @param {String} pictureName 
     * @returns {KunSceneManager}
     */
    KunSceneManager.resume = function( pictureName ){
        return this;
    };

    /**
     * @param {String} pictureName 
     * @param {String} layerName 
     * @returns {KunSceneManager}
     */
    KunSceneManager.overrideSet = function( pictureName , layerName ){
        if( this.isPlaying( pictureName)){
            this._scenes[ pictureName ].changeLayer(layerName, true ) ;
            if( KunSceneManager.debug( KunSceneManager.DebugMode().TraceLog ) ){
                KunSceneManager.DebugLog(`Playing ${pictureName}.${layerName}`);
            }    
            this.updateTouchPoints(this.countTargets());
        }
        else if(KunSceneManager.debug( )){
            KunSceneManager.DebugLog(`${pictureName}.${layerName} is not playing in the current scene`);
        }
        return this;
    };
    /**
     * 
     * @param {String} pictureName 
     * @param {Number} fps 
     * @returns {KunSceneManager}
     */
    KunSceneManager.overrideFPS = function( pictureName , fps ){
        if( this.isPlaying( pictureName ) ){
            this._scenes[ pictureName ].setFps( fps );
        }
        return this;
    };
    /**
     * @param {String} sfx
     * @returns KunSceneManager
     */
    KunSceneManager.playFx = function( sfx ){
        KunSceneManager.PlayFX( typeof sfx === 'string' && sfx.length ? sfx : this.sfx() );
        return this;
    };

/*KunSceneManager.PluginParameters = function(){
    return PluginManager.parameters('KunAnimations');
};*/


/**
 * @param {String} sfx 
 * @param {Number} pitch
 * @param {Number} pan
 */
KunSceneManager.PlayFX = function( sfx , pitch , pan ){
        if(  sfx.length ){
            if( typeof pitch !== 'number' ){
                pitch = 90 + Math.floor(Math.random() * 20);
            }
            if( typeof pan !== 'number' ){
                pan = Math.floor(Math.random() * 20) - 10;
            }
            this.AudioManager( sfx , 100 , pitch , pan );
            //AudioManager.playSe({name: sfx , pan: pan, pitch: pitch, volume: 100});
        }
};
/**
 * 
 * @param {String} se 
 * @param {Number} volume 
 * @param {Number} pitch 
 * @param {Number} pan 
 * @param {Boolean} interrupt
 */
KunSceneManager.AudioManager = function( se , volume , pitch , pan , interrupt ){
    if( se.length ){
        if( typeof interrupt === 'boolean' && interrupt ){
            AudioManager.stopSe();
        }
        //KunSceneManager.DebugLog( `Playing ${se} at vol ${volume}, pitch ${pitch} and pan ${pan} ${interrupt}` );
        AudioManager.playSe({name: se , pan: pan || 0, pitch: pitch || 100, volume: volume || 90 } );
    }
};
/**
 * @param {String} message 
 */
KunSceneManager.DebugLog = function( message ){
    if( KunSceneManager.debug() ){
        console.log( typeof message === 'object' ? message : `[ KunSceneManager ] ${message.toString()}` );
    }
};
/**
 * @param {String} name 
 * @returns Boolean
 */
/*KunSceneManager.SoundEffectExists = function( name ){
    return this.FileExists( this.FilePath( name + AudioManager.audioFileExt() ) );
}*/
/**
 * @param {String} path 
 * @returns Boolean
 */
/*KunSceneManager.FileExists = function( path ){

    var fs = require('fs');
    if( fs.existsSync( path )){
        return true;
    }

    if( KunSceneManager.debug( KunSceneManager.DebugMode().TraceLog ) ){
        KunSceneManager.DebugLog( `File missing ${path}` );
    }

    return false;
};*/
/**
 * @param {String} file 
 * @returns String
 */
KunSceneManager.FilePath = function( file ){
    var path = require('path');
    var base = path.dirname(process.mainModule.filename);
    return path.join(base, `audio/se/${file}`);
};

/**
 * @returns Object
 */
KunSceneManager.Mode = function(){
    return {
        'Disabled': 'disabled',
        'Touch': 'touch',
        'Capture': 'capture',
    };
};
KunSceneManager.Behavior = {
    'Forward': 'forward',
    'Reverse': 'reverse',
    'PingPong': 'ping-pong',
    'Static': 'static',
};

KunSceneManager.Capture = [];




function KunSceneImporter(){

};
/**
 * @param {Number} animPack
 * @returns Object
 */
KunSceneImporter.PluginData = function ( animPack ) {

    var _KunAnimations = 'KunAnimations';
    if( typeof animPack === 'number' && animPack > 0 ){
        _KunAnimations += '-' + animPack.toString();
    }

    function _parsePluginData ( key , value ) {
        if (typeof value === 'string' && value.length ) {
            try {
                if (/^\{.*\}$|^\[.*\]$/.test(value)) {
                    return JSON.parse(value, _parsePluginData );
                }
            } catch (e) {
                // If parsing fails or it's not an object/array, return the original value
            }
            if( value === 'true' || value === 'false'){
                return value === 'true';
            }
            if( !isNaN(value) ){
                return parseInt(value);
            }
        }
        else if( typeof value === 'object' && !Array.isArray(value) ){
            var _output = {};
            Object.keys( value ).forEach( function(key ){
                _output[key] = _parsePluginData( key , value[key] );
            });
            return _output;
        }
        return value;
    };

    return _parsePluginData( _KunAnimations, PluginManager.parameters(_KunAnimations));
};
/**
 * @param {Array} base 
 * @returns Array
 */
KunSceneImporter.importAnimationPacks = function( base ){
    // import more Animation packages from external plugin
    //return typeof KunAnimationPacks === 'function' ? KunAnimationPacks.initialize().import( base ) : base;
    var packs = PluginManager.parameters('KunAnimationPack');
    for( var i = 0 ; i < KunSceneManager.animationPacks() ; i++ ){
        var header = 'pack' + ( i + 1).toString();
        if( packs.hasOwnProperty( header ) && packs[header].length > 0 ){
            var counter = 0;
            JSON.parse(packs[header]).forEach( function( pack ){
                base.push(pack);
                counter++;
            });
            KunSceneManager.DebugLog( `Added ${counter} scenes from ${header} extension.` );
        }
    }

    return base;
};
/**
 * @param {String} content 
 * @param {Object} onDefault 
 * @returns Object
 */
KunSceneImporter.parse = function( content , onDefault ){
    return typeof content === 'string' && content.length ? JSON.parse( content ) : (onDefault || null);
};
/**
 * @param {String} content 
 * @returns Array
 */
KunSceneImporter.parseArray = function( content ){
    return typeof content === 'string' && content.length > 0 ?  (/^\[.*\]$/.test(content) ? JSON.parse(content) : [content])   : []
};

/**
 * @param {Object[]} input 
 * @returns KunSceneManager
 */
KunSceneManager.ImportScenes = function( input ){

    var _spotCounter = 0;
    var _layerCounter = 0;
    var _pictureCounter = 0;
    var _actionCounter = 0;
    var _conditionCounter = 0;

    //input.map( ctl => ctl.length > 0 ? JSON.parse( ctl ) : null ).forEach(function( ctl ){
    KunSceneManager.importAnimationPacks( input ).map( controller => KunSceneImporter.parse( controller ) ).filter( controller => controller !== null ).forEach(function( ctl ){
            //var _pictures = typeof ctl.source === 'string' && ctl.source.length > 0 ?  (/^\[.*\]$/.test(ctl.source) ? JSON.parse(ctl.source) : [ctl.source])   : [];
            //var prefix = typeof ctl.prefix === 'string' && ctl.prefix.length > 0 ? JSON.parse( ctl.prefix ) : [];
            var _pictures = KunSceneImporter.parseArray(ctl.source);
            var prefix = KunSceneImporter.parseArray( ctl.soundBankPrefix );
            var _scenes = [];
            var _spots = {};

            //Match fix to the next update and backwards compatibility with a single string value
            for( var i = 0 ; i < _pictures.length ; i++ ){
                _scenes.push( new KunAnimationScene(
                    _pictures[i],
                    parseInt(ctl.cols),
                    parseInt(ctl.rows),
                    parseInt( ctl.fps || 0 ),
                    prefix.length > i ? prefix[i] : '' ) );
            }
            //import all scene defined hotspots
            (Array.isArray(ctl.hotspots) ? ctl.hotspots : []).forEach( function(spot){
                if( !_spots.hasOwnProperty( spot.name ) ){
                    _spots[spot.name] = spot;
                }
            });

            //prepare the layer framesets
            (Array.isArray(ctl.framesets) ? ctl.framesets : []).forEach( function( layer ){
                _scenes.forEach(function(scene){
                    scene.add(KunSceneImporter.importLayer(layer,_spots));
                });
            });
            KunSceneImporter.parse( ctl.framesets , [] ).map( fs => KunSceneImporter.parse( fs ) ).filter( fs => fs !== null ).forEach(function(fs){
                    _layerCounter++;
                    //leave this here for debugging.
                    if( KunSceneManager.debug(KunSceneManager.DebugMode().TraceLog) ){
                        KunSceneManager.DebugLog(`Reading ${ctl.source}.${fs.name}`);
                    }
                    var _layer = new KunAnimationLayer(
                        fs.name ,
                        fs.type ,
                        parseInt(fs.fps) ,
                        parseInt( fs.loops),
                        fs.next.length > 0 ? JSON.parse(fs.next) : '' ,
                        //typeof fs.bank === 'string' && fs.bank.length > 0 ?  (/^\[.*\]$/.test(fs.bank) ? JSON.parse(fs.bank) : [fs.bank])   : [], //Match fix to the next update and backwards compatibility with a single string value
                        KunSceneImporter.parseArray( fs.bank ),
                        fs.offsetX, fs.offsetY,
                        fs.clearTargets === 'true' );
                    //( fs.frames.length > 0 ? JSON.parse(fs.frames) : [] ).map( frame => parseInt( frame ) ).forEach(function( frame ){
                    //import layer frames
                    KunSceneImporter.parse( fs.frames , [] ).map( frame => parseInt( frame ) ).forEach(function( frame ){
                        _layer.add( frame );
                    });
                    //import layer actions
                    (Array.isArray(fs.actions) ? fs.actions : []).forEach( function( action ){
                        _layer.addAction( KunSceneImporter.importAction(action) );
                    });

                    //import layer conditions
                    (Array.isArray(fs.conditions) ? fs.conditions : []).forEach( function( condition ){
                        _layer.addCondition( KunSceneImporter.importCondition(condition) );
                    });
                    //( _events ).map( s => s.length > 0 ? JSON.parse(s) : null ).forEach(  function( s ){
                    //import layer events
                    KunSceneImporter.parse( fs.spots , []).map( spot => KunSceneImporter.parse( spot ) ).forEach(  function( spot ){
                            var event = new KunTouchEvent(
                                spot.name,
                                parseInt(_spots[spot.name].x1),
                                parseInt(_spots[spot.name].y1),
                                parseInt(_spots[spot.name].x2),
                                parseInt(_spots[spot.name].y2),
                                parseInt(_spots[spot.name].varId || 0),
                                parseInt(_spots[spot.name].amount || 1),
                                _spots[spot.name].behavior || KunTouchEvent.Behaviour.Increase,
                                spot.trigger || KunTouchEvent.Trigger.Queue,
                                _spots[spot.name].sfx,
                                //spot.next.length > 0 ? JSON.parse(s.next) : []  );
                                KunSceneImporter.parseArray( spot.next , [] )  );
                            _layer.registerSpot(event);
                            _spotCounter++;
                    });
                    //KunSceneManager.DebugLog( _layer.spots() );
                    if( _layer.count() > 0 ){
                        _scenes.forEach( function( scene ){
                            scene.add( _layer );
                        } );
                    }
            });

            _scenes.forEach( function( scene ){
                if( scene.countFrames() ){
                    KunSceneManager.addScene( scene );
                }
            });
    });
    //leave this here for debugging.
    if( KunSceneManager.debug(KunSceneManager.DebugMode().TraceLog) ){
        KunSceneManager.DebugLog(`Imported a total of ${_pictureCounter} animated pictures, ${_layerCounter} animation layers and ${_spotCounter} hotspots`);
        KunSceneManager.DebugLog(`Imported a total of ${_actionCounter} actions and  ${_conditionCounter} conditions`);
    }

    return this;
};
/**
 * 
 * @param {Object} layer 
 */
KunSceneImporter.importLayer = function( layer ){

};
/**
 * 
 * @param {Object} action 
 * @returns KunLayerAction
 */
KunSceneImporter.importAction = function( action ){
    return new KunLayerAction(
        action.var || 0,
        action.op || '',
        action.val,
        action.switchOn,
        action.switchOff
    );
};
/**
 * 
 * @param {Object} condition 
 */
KunSceneImporter.importCondition = function( condition ){
    return new KunLayerCondition(
        condition.var || 0,
        condition.op || '',
        condition.val || 0,
        condition.sw || 0
    );
};
/**
 * 
 * @param {Object} touchSpot 
 */
KunSceneImporter.importTouchSpot = function( touchSpot ){

};


function KunAnimationScene( name , cols , rows , fps , prefix ){

    this._name = name;
    this._cols = cols || 1;
    this._rows = rows || 1;
    this._animationLayers = {
        //setup frameset collection here
    };
    this._elapsed = 0;
    this._loopCount = 0;
    this._reverse = false;
    this._playing = false;

    this._index = 0;
    this._current = '';

    this._defaultFps = fps || KunSceneManager.defaultFps();
    //this one can be overriden
    this._fps = this._defaultFps;
    this._touching = false;
    this._prefix = typeof prefix === 'string' && prefix.length ? prefix : '';
    //this._touch = [];
    //use this to capture coordinates in Dev Mode
    this._capture = [];
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.isValid = function(){
    return this._name !== 'INVALID' && !this.empty();
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.isReady = function(){
    return this._current.length > 0 && this.has(this._current);
};
/**
 * @returns String
 */
KunAnimationScene.prototype.toString = function(){ return this.name(); };
/**
 * @returns String
 */
KunAnimationScene.prototype.name = function(){ return this._name; };
/**
 * @returns KunAnimationLayer
 */
KunAnimationScene.prototype.current = function(){ return this.isReady() ? this.layers()[this._current] : null; };
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.canTouch = function(){
    var current = this.current();
    return current !== null ? current.isInteractive() : false;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent
 */
KunAnimationScene.prototype.getTouched = function( x , y ){

    var current = this.current();
    return current !== null ? current.touchSpot( x , y ) : null;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @param {Number} sx
 * @param {Number} sy
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.touch = function( x  , y , sx , sy){
    //console.log(`${x},${y} (${sx},${sy})`);
    //console.log(this.current().name());
    var spot = this.getTouched(x , y);
    //console.log( spot );
    if( spot !== null ){
        switch( spot.trigger() ){
            case KunTouchEvent.Trigger.Queue:
                //KunSceneManager.enqueue( `${this.name()}.${spot.name()}` , x , y , sx , sy );
                KunSceneManager.enqueue( this.name() , spot.name() , sx , sy );
                break;
            case KunTouchEvent.Trigger.Instant:
                //perform spot update
                spot.update();
                //export X and Y positions
                KunSceneManager.exportPosition( sx , sy );
                //jump to next frameset (if any)
                this.changeLayer( spot.next(), true );
                break;
            case KunTouchEvent.Trigger.Frame:
                this.changeLayer(spot.next());
                spot.setValue(this.current().first()).touchSfx();
                break;
        }
        
    }
    return this;
};
/**
 * @returns Array
 */
KunAnimationScene.prototype.capture = function(){
    return this._capture;
};
/**
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.captureFrom = function( x , y ){
    this._capture = [x , y];
    return this;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.captureTo = function( x , y ){
    if( this._capture.length === 2 ){
        this._capture.push(x);
        this._capture.push(y);
        //sort and arrrange
        if( this._capture[0] > this._capture[2]){
            var mx = this._capture[0];
            this._capture[0] = this._capture[2];
            this._capture[2] = mx;
        }
        if( this._capture[1] > this._capture[3]){
            var my = this._capture[1];
            this._capture[1] = this._capture[3];
            this._capture[3] = my;
        }
        KunSceneManager.DebugLog( `Capture Coords: ${this._capture.join( ' ' )}` );
    }
    return this.clearCapture();
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.clearCapture = function(){
    this._capture = [];
    return this;
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.playing = function(){ return this._playing; }
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.stop = function(){
    this._playing = false;
    return this;
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.resume = function(){
    this._playing = true;
    return this;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.getFrame = function(){
    return this.isReady() ? this.layers()[this._current].getFrame( this._index ) : 0;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.index = function(){ return this._index; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.cols = function(){ return this._cols; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.rows = function(){ return this._rows; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.totalFrames = function(){ return this._cols * this._rows; };
/**
 * @param {String} layer 
 * @returns Boolean
 */
KunAnimationScene.prototype.has = function( layer ){
    return typeof layer === 'string' && layer.length > 0 && this.layers().hasOwnProperty( layer );
}
/**
 * @param {KunAnimationLayer} layer 
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.add = function( layer ){
    if( layer instanceof KunAnimationLayer ){
        this.layers()[ layer.name() ] = layer;
        if( this._current.length === 0 ){
            this._current = layer.name();
            //this.changeLayer( layer.name());
        }
    }
    return this;
};
/**
 * @param {Number} fps 
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.setFps = function( fps ){
    switch( true ){
        case typeof fps === 'number' && fps > 0:
            this._fps = fps;
            break;
        case this.has(this._current):
            this._fps = this.current().fps() || this.defaultFps();
            break;
        default:
            this._fps = this.defaultFps();
            break;
    }
    return this;
};
/**
 * @param {Boolean} list 
 * @returns KunAnimationLayer[] | Object
 */
KunAnimationScene.prototype.layers = function( list ){
    return typeof list === 'boolean' && list ? Object.values( this._animationLayers ) : this._animationLayers;
}
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.empty = function(){
    return this.layers(true).length === 0;
};
/**
 * @returns {Number}
 */
KunAnimationScene.prototype.countFrames = function(){
    return this.has(this._current) ? this.current().count() : 0;
};
/**
 * @param {String} layer
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.beforeChangeLayer = function( layer ){
    if( this.has(layer) && this.layers()[layer].clearTargetQueue()){
        //clear target queue on change from this scene to another
        KunSceneManager.clearTargets();
    }
    return this;
};
/**
 * @param {String} layer 
 * @param {Boolean} play
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.changeLayer = function( layer , play ){
    if( this.has( layer ) ){
        this.beforeChangeLayer( layer );
        this._current = layer;
        var layerFps = this.current().fps();
        return this.reset( typeof play === 'boolean' && play ).setFps(layerFps).afterChangeLayer();
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.afterChangeLayer = function( ){
    var current = this.current();
    if( current !== null ){
        //run all enqueued actions
        current.runActions();
    }
    return this;
};
/**
 * @param {String[]} layers
 * @param {Boolean} filterLocked
 * @returns {String}
 */
KunAnimationScene.prototype.selectLayer = function( layers , filterLocked ){
    if( typeof filterLocked === 'boolean' && filterLocked ){
        layers = this.layers(true)
            .filter( fs => layers.includes(fs.name()) && fs.isUnlocked())
            .map( fs => fs.name());
    }
    switch( true ){
        case layers.length > 1:
            return layers[ Math.floor( Math.random() * layers.length ) ];
        case layers.length > 0:
            return layers[0];
        default:
            return '';
    }
}
/**
 * @param {Boolean} replay
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.next = function( replay ){
    var next = this.isReady() ? this.selectLayer( this.current().next() , true ) : '';
    if( next.length > 0 ){
        return this.changeLayer( next , true );
    }
    if( typeof replay === 'boolean' && replay ){
        return this.reset(true);
    }
    else{
        this._playing = false;
    }
    return this;
};
/**
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.first = function(){
    if(!this.empty()){
        return this.changeLayer(this.layers(true)[0].name(), true );
    }
    return this;
};
/**
 * @param {Boolean} play
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.reset = function( play ){
    this._loopCount = this.current().loops();
    switch(this.current().behavior()){
        case KunSceneManager.Behavior.Reverse:
            this._reverse = true;
            this._index = this.countFrames() - 1;
            break;
        case KunSceneManager.Behavior.Forward:
            this._reverse = false;
            break;
        case KunSceneManager.Behavior.PingPong:
            this._reverse = false;
            break;
        case KunSceneManager.Behavior.Static:
            break;
    }
    this._playing = (typeof play === 'boolean' && play ) || this._playing;
    return this.playSound( this._prefix );
}
/**
 * @param {Number} round
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.playSound = function( round ){
    if( this.playing() ){
        this.current().playSound( this._prefix , round );
    }
    return this;
};
/**
 * @returns {KunAnimationScene}
 */
/*KunAnimationScene.prototype.playBankByRound = function( loop ){
    if( this.playing() ){
        var bank = this.current().getSoundCollection();
        if( bank.length > 0 ){
            KunSceneManager.playSound( bank , loop );
        }
    }
    return this;
};*/
/**
 * @returns Number
 */
KunAnimationScene.prototype.defaultFps = function(){
    return this._defaultFps;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.FPS = function(){
    return this._fps;
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.tick = function(){
    this._elapsed = ++this._elapsed % this.FPS();
    return this._elapsed === 0;
};
/**
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.update = function(){
    if( this.playing() ){
        if( this.tick() ){
            switch( this.current().behavior() ){
                case KunSceneManager.Behavior.PingPong:
                    this.updatePingPong();
                    break;
                case KunSceneManager.Behavior.Reverse:
                    this.updateReverse();
                    break;
                case KunSceneManager.Behavior.Static:
                    //do not change
                    break;
                case KunSceneManager.Behavior.Forward:
                default:
                    this.updateForward();
                    break;
            }
            //this.changeLayer(KunSceneManager.getOverride(this._name));
    
            return true;
        }    
    }
    return false;
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.updatePingPong = function(){
    if( !this._reverse ){
        //ping
        this._index = ( this._index + 1 ) % this.countFrames();
        if( this._index === 0 ){
            this._reverse = true;
        }
    }
    else if(this._index > 0){
        //pong
        this._index--;
    }
    //after complete the round
    if( this._index === 0 && this._reverse ){
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playSound(this._loopCount);
        }
        this._reverse = false;
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.updateReverse = function(){
    if( this._index > 0 ){
        this._index--;
    }
    else{
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playSound(this._loopCount);
        }
        //reset counter
        this._index = this.countFrames() - 1;
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.upadteForward_BACKUP = function(){
    this._index = ( this._index + 1 ) % this.countFrames();
    //check this conditiojn first, then update index, also run when index points to last frame.
    if( this._index === 0 ){
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playSound(this._loopCount);
        }
        //this._index = 0;
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.upadteForward = function(){
    //check this conditiojn first, then update index, also run when index points to last frame.
    if( this._index === this.countFrames() - 1 ){
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playSound(this._loopCount);
        }
        //this._index = 0;
    }
    this._index = ( this._index + 1 ) % this.countFrames();
    return this;
}

/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.instance = function(){
    var copy = new KunAnimationScene( this._name, this._cols,this._rows , this.FPS() , this._prefix );
    copy._frameSets = this.layers();
    copy._current = this._current;
    return copy.reset();
};
/**
 * @returns KunAnimationScene|Object
 */
KunAnimationScene.prototype.dump = function(){
    return this;
};

/**
 * @returns 
 */
KunAnimationScene.INVALID = new KunAnimationScene('INVALID');


//function KunAnimationLayer(){ this.initialize.apply( this , arguments ); };
//KunAnimationLayer.prototype = Object.create(Sprite.prototype);
/**
 * 
 * @param {String} name 
 * @param {String} type 
 * @param {Number} fps 
 * @param {Number} loops 
 * @param {String} next 
 * @param {String} bank
 * @param {Number} offsetX
 * @param {Number} offsetY
 */
//KunAnimationLayer.prototype.initialize = function( name , type , fps, loops , next , bank , offsetX , offsetY , clearTargets ){
function KunAnimationLayer( name , type , fps, loops , next , bank , offsetX , offsetY , clearTargets ){
    this._name = name.toLowerCase().replace(/[\s\_]/,'-');
    this._fps = typeof fps === 'number' && fps > 0 ? fps : 0;
    this._frames = [];
    this._type = type || KunSceneManager.Behavior.Default;
    this._loops = loops || 0;
    this._offsetX = offsetX || 0;
    this._offsetY = offsetY || 0;
    this._clearTargets = typeof clearTargets === 'boolean' && clearTargets;
    this._spots = {
        //interactive spots to touch
    };
    this._next = Array.isArray( next ) ? next  : ( typeof next === 'string' && next.length ? [next] : [] );
    this._bank = Array.isArray(bank) ? bank : ( typeof bank === 'string' && bank.length ? [bank] : []) ;

    this._actions = [
        //add here all actions to run when this frameset plays
    ];
    this._conditions = [
        //add here all conditions to run when this frameset plays
    ];
};
/**
 * @param KunLayerAction action
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.addAction = function( action ){
    if( action instanceof KunLayerAction ){
        this._actions.push( action );
    }
    return this;
};
/**
 * @returns KunLayerAction[]
 */
KunAnimationLayer.prototype.actions = function(){
    return this._actions;
};
/**
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.runActions = function(){
    //KunSceneManager.DebugLog(`Preparing ${this.actions().length.toString()} actions for layer ${this.name()}`);
    this.actions().filter( action => action.canRun( ) ).forEach( action => action.run() );
    return this;
};
/**
 * @param KunLayerCondition condition
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.addCondition = function( condition ){
    if( condition instanceof KunLayerCondition ){
        this._conditions.push( condition );
    }
    return this;
};
/**
 * @returns KunLayerCondition[]
 */
KunAnimationLayer.prototype.conditions = function(){
    return this._conditions;
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.isUnlocked = function(){
    if( this.conditions().length ){
        var notPassed = this.conditions().filter( condition => !condition.validate() );
        //KunSceneManager.DebugLog( notPassed ? `${this.name()} didn't pass the validation` : `${this.name()} passed the validation!` );
        return notPassed.length === 0;    
    }
    return true;
};
/**
 * 
 * @returns 
 */
KunAnimationLayer.prototype.randomSpot = function(){
    var list = this.spots(true);
    return list[Math.floor( Math.random() * list.length)];
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.clearTargetQueue = function( ){
    return this._clearTargets;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.offsetX = function( ){
    return this._offsetX;
    if( typeof scale !== 'number'){
        scale = 1;
    }
    return parseInt( this._offsetX * scale );
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.offsetY = function( ){
    return this._offsetY;
    if( typeof scale !== 'number'){
        scale = 1;
    }
    return parseInt( this._offsetY * scale );
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.isInteractive = function(){
    return this.spots(true).length > 0;
};
/**
 * 
 * @param {KunTouchEvent} spot 
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.registerSpot = function( spot ){

    if( spot instanceof KunTouchEvent && !this._spots.hasOwnProperty(spot.name()) ){
        //
        this._spots[spot.name()] = spot;
    }

    return this;
};
/**
 * List all spots as array or object ids
 * @param {Boolean} list 
 * @returns Object | KunTouchEvent[]
 */
KunAnimationLayer.prototype.spots = function( list ){
    return typeof list === 'boolean' && list ? Object.values( this._spots ) : this._spots;
}
/**
 * @param {String} spot 
 * @returns Boolean
 */
KunAnimationLayer.prototype.hasSpot = function( spot ){
    return this._spots.hasOwnProperty(spot);
}
/**
 * @param {String} spot 
 * @returns KunTouchEvent
 */
KunAnimationLayer.prototype.getSpot = function( spot ){
    return this.hasSpot(spot) ? this._spots[spot] : null;
}
/**
 * Check if any spot was touched
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent 
 */
KunAnimationLayer.prototype.touchSpot = function( x , y ){
    var hotspots = this.spots(true);
    for( var i in hotspots ){
        //hotspots[i].test( x , y );
        if( hotspots[i].touched( x , y ) ){
            //console.log( `${hotspots[i]} touched on ${x},${y}` );
            return hotspots[i];
        }
    }
    return null;
};
/**
 * @returns String
 */
KunAnimationLayer.prototype.behavior = function(){
    return this._type;
};
/**
 * @param {Number} frame 
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.add = function( frame ){
    this._frames.push( frame );
    return this;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.fps = function(){
    return this._fps;
    //return this._fps > 0 ? this._fps : KunSceneManager.defaultFps();
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.loops = function(){
    return this._loops;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.frames = function( ){
    return this._frames.length > 0 ? this._frames : [0];
}
/**
 * @returns Number
 */
KunAnimationLayer.prototype.first = function(){
    return this.frames().length > 0 ? this.frames()[0] : 0;
};
/**
 * @param {Number} index 
 * @returns Number
 */
KunAnimationLayer.prototype.getFrame = function( index ){
    return this._frames.length > index ? this._frames[index] : this._frames[0];
    return this._frames.length > index ? this._frames[index] : 0;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.count = function(){
    return this.frames().length;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.name = function(){
    return this._name;
};
/**
 * @returns String[]
 */
KunAnimationLayer.prototype.next = function(){
    return this.nextLayers();
};
/**
 * @returns String[]
 */
KunAnimationLayer.prototype.nextLayers = function(){
    return this._next;
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.hasSoundBank = function(){
    return this._bank.length > 0;
};
/**
 * @param {String} prefix
 * @returns String
 */
KunAnimationLayer.prototype.getSoundCollection = function( prefix ){
    if( this.hasSoundBank() ){
        var selection = this._bank.length > 1 ? Math.floor(Math.random() * this._bank.length) : 0;
        return typeof prefix === 'string' && prefix.length ? prefix + '-' + this._bank[selection] : this._bank[selection];
    }
    return '';
};
/**
 * @param {String} prefix
 * @param {Number} round
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.playSound = function( prefix , round ){
    KunSceneManager.playSound( this.getSoundCollection( prefix ) , round );
    return this;
};

/**
 * 
 * @param {String} name 
 * @param {Number} x1 
 * @param {Number} y1 
 * @param {Number} x2 
 * @param {Number} y2 
 * @param {Number} varId
 * @param {String} behavior
 * @param {String} sfx
 * @param {String} next
 */
function KunTouchEvent( name , x1 , y1 , x2 , y2 , varId , amount , behavior, trigger, sfx , next  ){

    this._name = name;
    this._x1 = parseInt( x1 );
    this._y1 = parseInt(y1);
    this._x2 = parseInt(x2);
    this._y2 = parseInt(y2);
    this._varId = parseInt(varId || 0 );
    this._amount = typeof amount === 'number' && amount > 0 ? amount : 1;
    this._behavior = typeof behavior === 'string' && behavior.length ? behavior : KunTouchEvent.Behaviour.Add;
    this._trigger = typeof trigger === 'string' && trigger.length ? trigger : KunTouchEvent.Trigger.Queue;
    this._sfx = sfx || '';
    this._next = next || [];

    this._hotspot = null;
}
/**
 * @returns String
 */
KunTouchEvent.prototype.toString = function(){
    return `${this.name()} (${this._x1} ${this._y1} ${this._x2} ${this._y2})`;
}
/**
 * @returns String
 */
KunTouchEvent.prototype.name = function(){
    return this._name;
};
/**
 * @returns Object {x,y} coordinates of the selected spot
 */
KunTouchEvent.prototype.generatePosition = function(){
    var x = Math.floor(Math.random() * (this._x2 - this._x1)) + this._x1;
    var y = Math.floor(Math.random() * (this._y2 - this._y1)) + this._y1;
    return {
        'x':x,
        'y':y,
    };
};
/**
 * @returns String[]
 */
KunTouchEvent.prototype.nextLayers = function(){
    return this._next;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.next = function(){
    var jumpTo = this._next.length > 1 ? Math.floor( Math.random() * this._next.length) : 0;
    return this._next.length > 0 ? this._next[ jumpTo ] : '';
};
/**
 * @returns Number
 */
KunTouchEvent.prototype.amount = function(){
    return this._amount;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.behavior = function(){
    return this._behavior;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.trigger = function(){
    return this._trigger;
};
/**
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.touchSfx = function(){
    if( this._sfx.length ){
        KunSceneManager.PlayFX( this._sfx );
    }
    return this;
}
KunTouchEvent.prototype.setValue = function( value ){
    if( this._varId > 0 ){
        $gameVariables.setValue( this._varId , value );
    }
    return this;
};
/**
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.update = function(){
    if( this._varId > 0 ){
        switch( this.behavior()){
            case KunTouchEvent.Behaviour.Add:
            case KunTouchEvent.Behaviour.Increase: //deprecated
                this.setValue( $gameVariables.value(this._varId) + this.amount() );
                break;
            case KunTouchEvent.Behaviour.Substract:
                var amount = $gameVariables.value(this._varId) - this._amount();
                this.setValue( amount > 0 ? amount : 0 );
                break;
            case KunTouchEvent.Behaviour.Set:
                this.setValue( this.amount() );
                break;
            //case KunTouchEvent.Behaviour.Frame:
                //this.setValue( $gameVariables.value(this._varId) + 1 );
            //    break;
        }
    }
    return this;
}
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns 
 */
KunTouchEvent.prototype.touched = function( x , y ){
    return (this._x1 <= x && this._x2 >= x) && (this._y1 <= y && this._y2 >= y);
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.test = function( x , y){
    console.log( `${this.name()} X(${this._x1} >= ${x} <= ${this._x2}) Y(${this._y1} >= ${y} <= ${this._y2})` );
    return this;
};
/**
 * 
 */
KunTouchEvent.Trigger = {
    'Instant': 'instant',
    'Queue': 'queue',
    'Ignore': 'ignore',
    'Frame': 'frame',
};
/**
 * 
 */
KunTouchEvent.Behaviour = {
    'Increase': 'increase',
    'Add': 'add',
    'Substract': 'sub',
    'Set': 'set',
    'Frame': 'frame', //DEPRECATED
};
/**
 * Handle conditions to unlock available layers
 * @param {Number} gameVar 
 * @param {String} operation 
 * @param {Number} value 
 * @param {Number} gameSwitch
 */
function KunLayerCondition( gameVar , operation , value , gameSwitch ){
    this._gameSwitch = typeof gameSwitch === 'number' && gameSwitch > 0 ? gameSwitch : 0;
    this._gameVar = typeof gameVar === 'number' && gameVar > 0 ? gameVar : 0;
    this._operator = typeof operation === 'string' && operation.length > 0 ? operation : KunLayerCondition.Operators().Equal;
    this._value = typeof value === 'number' && value > 0 ? value : 1;
};
/**
 * @returns Number
 */
KunLayerCondition.prototype.value = function( ){
    return this._value;
};
/**
 * @param {Boolean} importGameVar 
 * @returns Number
 */
KunLayerCondition.prototype.gameVar = function( importGameVar ){
    return typeof importGameVar === 'boolean' && importGameVar ? $gameVariables.value(this.gameVar()) : this._gameVar;
};
KunLayerCondition.prototype.gameSwitch = function( importGameSwitch ){
    return typeof importGameSwitch === 'boolean' && importGameSwitch ? $gameSwitches.value(this.gameSwitch()) : this._gameSwitch;
};
/**
 * @returns String
 */
KunLayerCondition.prototype.operator = function( ){
    return this._operator;
};
/**
 * @returns Boolean
 */
KunLayerCondition.prototype.validate = function( ){
    if( this.gameVar() > 0 ){
        //validate variable
        switch( this.operator()){
            case KunLayerCondition.Operators.Greater:
                return this.gameVar(true) > this.value();
            case KunLayerCondition.Operators.GreaterOrEqual:
                return this.gameVar(true) >= this.value();
            case KunLayerCondition.Operators.Equal:
                return this.gameVar(true) = this.value();
            case KunLayerCondition.Operators.LowerOrEqual:
                return this.gameVar(true) <= this.value();
            case KunLayerCondition.Operators.Lower:
                return this.gameVar(true) < this.value();
        };    
    }
    if( this.gameSwitch() > 0 ){
        //validate switch
        return this.gameSwitch(true);
    }
    return true;
};
/**
 * 
 */
KunLayerCondition.Operators = {
    'Greater': 'greater',
    'GreaterOrEqual': 'greater_equal',
    'Equal': 'equal',
    'LowerOrEqual': 'lower_equal',
    'Lower': 'lower',
};

/**
 * Define a set of actions for each layer upon playing
 * @param {Number} gameVar 
 * @param {String} operation 
 * @param {Number} value 
 * @param {Number[]} gameSwitchesOn 
 * @param {Number[]} gameSwitchesOff 
 * @param {Boolean} runOnce 
 */
function KunLayerAction( gameVar , operation , value , gameSwitchesOn, gameSwitchesOff , runOnce ){

    this._gameVar = typeof gameVar === 'number' && gameVar > 0 ? gameVar : 0;
    this._operation = typeof operation === 'string' && operation.length ? operation : KunLayerAction.Operators.Add;
    this._value = typeof value === 'number' && value > 0 ? value : 0;
    this._switchOn = Array.isArray( gameSwitchesOn ) ? gameSwitchesOn.map( sw => parseInt( sw ) ) : [];
    this._switchOff = Array.isArray( gameSwitchesOff ) ? gameSwitchesOff.map( sw => parseInt( sw ) ) : [];

    this._runOnce = runOnce;
    this._rounds = 0;
};
/**
 * @returns String
 */
KunLayerAction.prototype.operation = function( ){
    return this._operation;
}
/**
 * @returns Boolean
 */
KunLayerAction.prototype.canRun = function( ){
    return this.rounds() < 1 || !this.runOnce();
}
/**
 * @returns Boolean
 */
KunLayerAction.prototype.runOnce = function( ){
    return this._runOnce;
}
/**
 * @returns Number
 */
KunLayerAction.prototype.rounds = function( ){
    return this._rounds;
}
/**
 * @returns KunLayerAction
 */
KunLayerAction.prototype.run = function( ){
    this._rounds++;
    return this.updateGameVar().switchOff().switchOn();
}
/**
 * @param {Boolean} importValue import the Current Value of this game variable
 * @returns Number
 */
KunLayerAction.prototype.gameVar = function( importValue ){
    return typeof importValue === 'boolean' && importValue ? $gameVariables.value(this._gameVar) : this._gameVar;
}
/**
 * @returns Number
 */
KunLayerAction.prototype.value = function( ){
    return this._value;
}
/**
 * @returns KunLayerActions
 */
KunLayerAction.prototype.updateGameVar = function(){
    switch( this.operation() ){
        case KunLayerAction.Operators.Add:
            $gameVariables.setValue( this.gameVar() , this.gameVar( true ) + this.value());
            break;
        case KunLayerAction.Operators.Sub:
            var current = this.gameVar( true );
            $gameVariables.setValue( this.gameVar() , current - this.value() > 0 ? current - this.value() : 0);
            break;
            case KunLayerAction.Operators.Set:
            $gameVariables.setValue( this.gameVar() , this.value());
            break;
    }
    this._switchOn.forEach( function( gameSwitch ){
        $gameSwitches.setValue(gameSwitch,true);
    });
    return this;
};
/**
 * @returns KunLayerActions
 */
KunLayerAction.prototype.switchOn = function(){
    this._switchOn.forEach( function( gameSwitch ){
        $gameSwitches.setValue(gameSwitch,true);
    });
    return this;
};
/**
 * @returns KunLayerActions
 */
KunLayerAction.prototype.switchOff = function(){
    this._switchOff.forEach( function( gameSwitch ){
        $gameSwitches.setValue(gameSwitch,false);
    });
    return this;
};
/**
 * 
 */
KunLayerAction.Operators = {
    'Add': 'add',
    'Sub': 'sub',
    'Set': 'set',
};
/**
 * 
 */
function KunAnimations_RegisterManagers(){

    var _kunAnimations_Initialize_Sprite = Sprite_Picture.prototype.initialize;
    Sprite_Picture.prototype.initialize = function( pictureId ){
        _kunAnimations_Initialize_Sprite.call(this,pictureId);
        this._touching = false;
    };

    var _kunAnimations_Load_Bitmap = Sprite_Picture.prototype.loadBitmap;
    Sprite_Picture.prototype.loadBitmap = function() {
        //vanilla image preload
        _kunAnimations_Load_Bitmap.call(this);
        //setup animation if its a scene spritesheet
        if( this.isAnimated() ){
            this.animationScene().reset(true); //initialize and play
            this.bitmap.addLoadListener(this.initializeAnimation.bind(this));
        }
    };

    var _kunAnimations_Update_Sprite = Sprite_Picture.prototype.update;
    Sprite_Picture.prototype.update = function(){
        //call vanilla
        _kunAnimations_Update_Sprite.call( this );

        if( this.isAnimated()){
            //update the scene manager
            this.updateAnimation( this.animationScene( ) ).processTouch();
        }
    };
    /**
     * @returns Sprite_Picture
     */
    Sprite_Picture.prototype.initializeAnimation = function( ){
        return this.updateAnimation( this.animationScene( ) , true );
    };
    /**
     * @param {KunAnimationScene} sceneController
     * @param {Boolean} forceUpdate
     * @returns Sprite_Picture
     */
    Sprite_Picture.prototype.updateAnimation = function( sceneController , forceUpdate ){
        if( sceneController.isValid() ){
            if( sceneController.update() || forceUpdate ){
                var index = sceneController.getFrame();
                var w = this.bitmap.width / sceneController.cols();
                var h = this.bitmap.height / sceneController.rows();
                var x = index % sceneController.cols() * w;
                var y = Math.floor(index / sceneController.cols()) * h;
                this.setFrame( x, y, w, h);
                //return true;                    
            }
        }
        return this;
    };
    /**
     * @returns KunAnimationScene
     */
    Sprite_Picture.prototype.animationScene = function(){
        return KunSceneManager.scene(this._pictureName);
    };
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.isAnimated = function(){
        return KunSceneManager.has(this._pictureName);
    }
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.isLoaded = function(){
        return typeof this.bitmap !== 'undefined' && this.bitmap !== null;
    };

    Sprite_Picture.prototype.isInteractive = function(){
        //capture from plugin animation data
        return this.animationScene().isInteractive();
    };
    /**
     * @param {Number} x 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetX = function( x ){
        return this.picture().scaleX() > 0 ? Math.floor((x - this.picture().x()) * 100 / this.picture().scaleX()) : 0;
    };
    /**
     * @param {Number} y 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetY = function( y ){
        return this.picture().scaleY() > 0 ? Math.floor((y - this.picture().y()) * 100 / this.picture().scaleY()) : 0;
    };
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.validScale = function(  ){
        return this.picture().scaleX() > 0 && this.picture().scaleY() > 0
    }
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.processTouch = function() {
        if( this.isAnimated() ){
            if (TouchInput.isTriggered()) {
                if( !this._touching ){
                    this._touching = true;
                }
                if(KunSceneManager.canCapture()){
                    this.animationScene().captureFrom( this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));
                }
            }
            if (TouchInput.isReleased()) {
                if (this._touching) {
                    this._touching = false;
                    //console.log( `Touch ${TouchInput._x},${TouchInput._y} (${this.validScale()})` );
                    //var picture = this.picture();
                    if(KunSceneManager.canCapture()){
                        this.animationScene().captureTo(this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));    
                    }
                    else if( KunSceneManager.canTouch() && this.validScale( ) ){
                        var X = TouchInput._x;
                        var Y = TouchInput._y;
                        this.animationScene().touch(this.offsetX(X), this.offsetY(Y), X, Y);
                    }
                }
            }
        }
        return this._touching;
    };

    //OVERRIDE Game_Picture move method to capture the picture offset when required
    var _kunAnimations_Game_Picture_Move = Game_Picture.prototype.move;
    Game_Picture.prototype.move = function(origin, x, y, scaleX, scaleY, opacity, blendMode, duration) {

        //capture X and Y offset from picture name
        if( this._name.length ){
            //import offset from currently active picture's frameset controller plus the scale
            var _offset = KunSceneManager.offset(this._name);
            //then apply the transformations
            x -= parseInt( _offset.x * (scaleX / 100) );
            y -= parseInt( _offset.y * (scaleY / 100) );
        }

        _kunAnimations_Game_Picture_Move.call(this,origin,x,y,scaleX,scaleY,opacity,blendMode,duration);
    };
}
/**
 * 
 */
function KunAnimations_SetupCommands(){
    var _KunAnimations_SetupCommands = Game_Interpreter.prototype.pluginCommand;
    Game_Interpreter.prototype.pluginCommand = function(command, args) {
        _KunAnimations_SetupCommands.call(this, command, args);
        if (command === 'KunAnimations' && args.length > 0 ) {
            switch( args[0] ){
                case 'alias':
                    if( args.length > 2 ){
                        KunSceneManager.setAlias( args[1] , args[2] );
                    }
                    break;
                case 'clear':
                    if( args.length > 1 ){
                        switch( args[1]){
                            case 'targets':
                                KunSceneManager.clearTargets();
                                break;
                            case 'alias':
                                KunSceneManager.clearAlias();
                                break;
                            case 'all':
                                KunSceneManager.clearAlias().clearTargets();
                                break;
                        }
                    }
                    else{
                        KunSceneManager.clearTargets();
                    }
                    break;
                case 'fps':
                    if( args.length > 2 ){
                        var fps = parseInt( args[2] );
                        if( args.length > 3 && args[3] === 'import' ){
                            fps = $gameVariables.value( fps );
                        }
                        KunSceneManager.overrideFPS( KunSceneManager.getAlias(args[1]) ,  fps );
                        //KunSceneManager.DebugLog(`FPS updated to ${fps}`);
                    }
                    break;
                case 'reset':
                    if( args.length > 1 ){
                        KunSceneManager.reset( KunSceneManager.getAlias(args[1]) , args.length > 2 && args[2] === 'replay' );
                    }
                    break;
                case 'set':
                    if( args.length > 2 ){
                        var frameSet = args[2].split('.');
                        var name = KunSceneManager.getAlias(args[1]);
                        if( frameSet.length > 1 ){
                            KunSceneManager.overrideSet( name , frameSet[ Math.floor( Math.random() * frameSet.length ) ] );
                        }
                        else{
                            KunSceneManager.overrideSet( name , frameSet[0] );
                        }
                        if( args.length > 3 && args[3] === 'wait'){
                            if ( args.length > 4 ){
                                var wait = args[4].split(':').map( count => parseInt(count));
                                this.wait( wait.length > 1 ? wait[0] + Math.floor( Math.random() * ( wait[1] - wait[0] ) ) : wait[0] );
                            }
                        }
                    }
                    break;
                case 'randomize':
                    if( args.length > 1 ){
                        var name = KunSceneManager.getAlias(args[1]);
                        KunSceneManager.randomTarget( name );
                    }
                    break;
                case 'pause':
                    if( args.length > 1 ){
                        KunSceneManager.stop( KunSceneManager.getAlias(args[1]) );
                        //KunSceneManager.DebugLog('Animation Paused');
                    }
                    break;
                case 'resume':
                    if( args.length > 1 ){
                        KunSceneManager.resume( KunSceneManager.getAlias(args[1]) );
                        //KunSceneManager.DebugLog('Animation Resumed');
                    }
                    break;
                case 'wait':
                    if( args.length > 1 ){
                        var wait = parseInt(args[1]);
                        if( args.length > 2 && args[2] === 'import' && wait > 0 ){
                            wait = $gameVariables.value( wait );
                        }
                        this.wait( wait );
                        KunSceneManager.DebugLog(`Waiting ${wait} fps ...`);
                    }
                    break;
                case 'target':
                    KunSceneManager.target(args.length > 1 && args[1] === 'random');
                    break;
                case 'interruption':
                    if( args.length > 1 ){
                        KunSceneManager.stopInterruption( args[1].toLowerCase() === 'on' );
                    }
                    else{
                        KunSceneManager.stopInterruption( false );
                    }
                    break;
                case 'mode':
                    KunSceneManager.setMode( args.length > 1  ? args[1] : KunSceneManager.Mode().Disabled );
                    if( KunSceneManager.canCapture() ){
                        KunSceneManager.DebugLog(`Capture Mode ON. Click and drag over a picture spot, then release to define the target area.`);
                    }
                    else{
                        KunSceneManager.DebugLog(`${KunSceneManager.mode()} mode on`);
                    }
                    break;
                case 'list':
                    KunSceneManager.list();
                    break;
            }
        }
    };

}

/********************************************************************************************************************
 * 
 * INITIALIZER
 * 
 *******************************************************************************************************************/

 (function( /* args */ ){

    KunSceneManager.Initialize();

    KunAnimations_RegisterManagers();

    KunAnimations_SetupCommands();
})( /* initializer */ );



