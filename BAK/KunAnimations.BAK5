//=============================================================================
// KunAnimations.js
//=============================================================================
/*:
 * @filename KunAnimations.js
 * @plugindesc Kun Interactive Picture Animations (Amirian Release) - Animate pictures with custom framesets and commands, now featuring an interactive framework to click over specific hotspots depending on the frameset running.
 * @version 3.15
 * @author KUN
 * @target MC | MZ
 * 
 * @help
 * 
 * COMMANDS:
 * 
 *      KunAnimations play|set animation-name [setName] [wait frames:frame_offset]
 *          Switch animation frameset setName for animation-name
 *          If offsetVarx and offsetVarY are defined, both vars will apply the defined offset
 *          Use offsetScale % to scale the offset displacement for each coordinate
 * 
 *      KunAnimations reset animation-name [replay]
 *          Resets the given animation
 *          Restarts the controller if replay is required
 * 
 *      KunAnimations fps animation-name [fps] [import]
 *          Set custom frames per second for the playing animation-name. Define import to use a Game Variable to grab the fps from
 * 
 *      KunAnimations variant [animation-name] [variant]
 *          Creates an additive variant percent value over the FPS and LOOP animation properties,
 *          to cause a duration and speed random behaviour.
 * 
 *      KunAnimations pause animation-name
 *          Pause animation-name if playing
 * 
 *      KunAnimations resume animation-name
 *          Resume animation-name if paused
 * 
 *      KunAnimations target [random]
 *          Update to the next target in the list of touched spots
 * 
 *      KunAnimations spot animation-name spot-name
 *          Export the X and Y coordinates of the spot-name area if available in the current animation play
 * 
 *      KunAnimations mode [playback|capture|touch|disabled]
 *          Set the mouse interactive mode. Set touch to activate the interactive events. Set capture to describe hotspot areas in the console (requires debug mode on). Set disable to turn off the event listener.
 * 
 *      KunAnimations clear [targets | alias]
 *          Clear the current target queue
 *          Clear targets or defined aliases
 * 
 *      KunAnimations alias [alias_name] [animation_name]
 *          Create an alias for a specific animation controller to ease picture swapping with the same tags
 * 
 *      KunAnimations wait [elapsed_seconds] [random_elapsed_seconds]
 *          Wait for elapsed seconds before running the next routines in the event editor
 *          Add random elapsed seconds to define a randomized timespan
 * 
 *      KunAnimations prepare | complete
 *          Resets all the active animations to prepare a new animation or close a running one.
 * 
 *      KunAnimations action [alias|picture] [action_tag]
 * 
 *      KunAnimations playlist [alias|picture] [clear|animation1:animation2:animation3:...]
 *          Create a playlist for a scene playback
 *          Use alias and picturenames alike
 *          Use clear command to remove a playlist
 *          Define a list of animations separated by :
 * 
 *      KunAnimations playback [alias|picture]
 *          Play an animation from the PlayBack manager
 *          Define playback mode to let the Animation Controller get the animations from the user's playlist
 * 
 *      KunAnimations playspot [alias|picture]
 *          Capture an interactive hotspot from the current playing animation of the given picture.
 *          Captured spot will export the registered X and Y Game Variables.
 * 
 *      KunAnimations stages [alias|picture] [stage:picture] [stage:picture] [stage:picture] [...]
 *          Binds a list of stages to this picture to replace the current playing picture with a single command line
 * 
 *      KunAnimations stage [alias|picture] [stage]
 *          Changes the current picture and animation to the defined stage
 *          Picture ID and animation alias will be moved to the next stage picture
 * 
 * 
 * HIERARCHY:
 * 
 *  -> Scene
 *  ----> AnimationLayer
 *  --------> TouchSpot
 * 
 *  - Animation Controllers
 *    defined by the Selected Picture File.
 *    Here you can setup the columns and rows, to properly display the frames.
 * 
 *  - Animation Frameset Groups
 *    A list of frames to play, with a custom FPS, behavior and looping iterations.
 * 
 *  - Touch Spots
 *    Every frameset animates a list of frames, but you can define on these a list of specific spots
 *    to click and cause a reaction, update a Game Variable, play a custom sound effect,
 *    and change to another specific frameset.
 * 
 * 
 * @param debug
 * @text Debug Level
 * @desc Show debug info. Activate Trace Log to detail the imports and exports of data.
 * @type select
 * @option TraceLog
 * @value 2
 * @option Enabled
 * @value 1
 * @option Disabled
 * @value 0
 * @default 0
 * 
 * @param defaultFPS
 * @text Master Frame Time
 * @desc default frame time
 * @type number
 * @min 1
 * @default 10
 * 
 * @param touchVarCounter
 * @text Touch Counter Variable
 * @desc This variable handles the counter of enqueued interactions performed by the player
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchVarLimit
 * @parent touchVar
 * @text Touch Limit Variable
 * @desc How many interactions can be saved in the queue. Can be updated in game to increase the touch events.
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchMode
 * @parent touchVar
 * @text Touch Mode Switch
 * @desc Use it to keep control of the interactive mode in the event editor. Use KunAnimations mode touch | disable to change it.
 * @type switch
 * @default 0
 * 
 * @param touchX
 * @text Touch X Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchY
 * @text Touch Y Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param wheel
 * @text wheel var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchSfx
 * @text Default Touch SE
 * @desc Define a default sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param cancelSfx
 * @text Don't Touch SE
 * @desc Define a no touch sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param selectSfx
 * @text Select SE
 * @desc Define a wheel/select sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param labels
 * @type string[]
 * @text Labels
 * @desc Assign labels to hotspot and animation names, displayable on command menus. Split with colon: [value:label]
 * 
 * @param scenes
 * @type struct<Scene>[]
 * @text Animation Scenes
 * @desc Define the DataBase of Animation Scene Controllers (keep it clean and easy!!)
 * 
 * @param controllers
 * @type struct<Scene>[]
 * @text Animation Scenes (OLD)
 * @desc Backward compatibility. Move to Animation Scenes (scenes)
 * 
 */
/*~struct~Scene:
 *
 * @param source
 * @text Source Picture Pack
 * @desc Add one or more source pictures with the same frameset columns and rows, to use with the same animation rules. Duplicated pictures will be discarded.
 * @type file[]
 * @require 1
 * @dir img/pictures/
 * 
 * @param cols
 * @text Columns
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param rows
 * @text Rows
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param fps
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param framesets
 * @type struct<Animation>[]
 * @text Animation
 * @desc Animation Frameset Collection
 * @default []
 * 
 * @param hotspots
 * @type struct<Spot>[]
 * @text HotSpots
 * @desc Add the interactive spots here
 * 
 * @param stages
 * @text Animation Stages
 * @type string[]
 * @desc Define here a relationship among this animation and other similar animations to quickload from the command
 * 
 * @param soundProfile
 * @type text[]
 * @text Sound Set Profile
 * @desc Add here the sound bank prefix for each picture souce when required
 * 
 * @param soundBankPrefix
 * @parent soundProfile
 * @type text[]
 * @text Sound Set Prefix
 * @desc Backwards compatibility
 * 
 * @param soundLoop
 * @parent soundProfile
 * @text Sound Loop
 * @desc Play sound effects after N loops
 * @type number
 * @min 0
 * @max 10
 * @default 4
 * 
 */
/*~struct~Animation:
 * 
 * @param name
 * @text Name
 * @type text
 * @default animation
 * 
 * @param frames
 * @text Frames
 * @type number[]
 * @min 0
 * @desc List of frames to play in this animation
 * @default []
 * 
 * @param type
 * @text Animation Type
 * @type select
 * @option Forward (default)
 * @value forward
 * @option Reverse
 * @value reverse
 * @option Ping-Pong
 * @value ping-pong
 * @option Static
 * @value static
 * @default forward
 * 
 * @param fps
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param loops
 * @type number
 * @text Loops
 * @desc number of times the animation will play before switching to the next animation. Leave it to 0 for endless loops (no next animation)
 * @default 0
 * 
 * @param next
 * @text Next FrameSets
 * @type text[]
 * @desc Define the next frameset to call. If more than one specified, they will be randomly called
 * 
 * @param offsetX
 * @text X Offset
 * @type number
 * @default 0
 * 
 * @param offsetY
 * @text Y Offset
 * @type number
 * @default 0
 * 
 * @param conditions
 * @type struct<Condition>[]
 * @text Conditions
 * @desc Enable this Animation when meeting these conditions
 * 
 * @param spots
 * @type struct<Touch>[]
 * @text Spots
 * @desc Interactive Spots to fire events
 * @default []
 * 
 * @param bank
 * @text Sound Sets
 * @desc Type in a defined sound bank name to play a special sound set each time this frameset is started.
 * @type text[]
 * @default []
 * 
 */
/*~struct~Touch:
 * 
 * @param name
 * @text Name
 * @type text
 * @default touch
 * 
 * @param next
 * @text Next Animation
 * @desc Jump to Frameset on touched (allow mrandom options when more than 1)
 * @type text[]
 * @default []
 * 
 */
/*~struct~Spot:
 * 
 * @param name
 * @text Name
 * @type text
 * @default touch
 * 
 * @param x1
 * @text X1
 * @type number
 * @min 0
 * @desc X origin coordinate
 * 
 * @param y1
 * @text Y1
 * @type number
 * @min 0
 * @desc Y origin coordinate
 * 
 * @param x2
 * @text X2
 * @type number
 * @min 0
 * @desc X destination coordinate
 * 
 * @param y2
 * @text Y2
 * @type number
 * @min 0
 * @desc Y destination coordinate
 * 
 * @param trigger
 * @text On Click
 * @type select
 * @option Instant Run
 * @value instant
 * @option Queue
 * @value queue
 * @option Set Frame
 * @value frame
 * @option Next Frame
 * @value next
 * @option Ignore
 * @value ignore
 * @default queue
 * 
 * @param sfx
 * @text Touch Audio SFX
 * @desc Define a specific sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param conditions
 * @type struct<Condition>[]
 * @text Conditions
 * @desc Enable this HotSpot when meeting these conditions
 * 
 * @param varId
 * @text Game Variable ID
 * @type variable
 * @min 0
 * @desc (Obsolete) Game Variable Mutator. Leave to 0 to not update variables. Use Actions instead.
 * @default 0
 * 
 * @param behavior
 * @parent varId
 * @text Update Behavior
 * @desc (Obsolete) How to modify the value on Game Variable ID. Use Actions instead
 * @type select
 * @option Add (default)
 * @value add
 * @option Substract
 * @value sub
 * @option Set
 * @value set
 * @default add
 * 
 * @param amount
 * @parent varId
 * @text Update Amount
 * @desc (Obsolete) Use Actions instead
 * @type number
 * @min 1
 * @default 1
 * 
 */
/*~struct~Action:
 * @param tag
 * @text Tag
 * @type text
 * @desc Set a tag for this action used for a filtered action selection
 * 
 * @param var
 * @type variable
 * @text Game Variable
 * @desc define a game variable to update with this action
 * @min 0
 * @default 0
 * 
 * @param op
 * @text Operator
 * @desc Operation type to run on the Game Variable
 * @type select
 * @option Add
 * @value add
 * @option Sub
 * @value sub
 * @option Set
 * @value set
 * @default set
 * 
 * @param val
 * @text Value
 * @desc Value to update the game variable with
 * @type number
 * @min 0
 * 
 */
/*~struct~Condition:
 *
 * @param var
 * @type variable
 * @text Game Variable
 * @desc define a game variable to check for this condition
 * @min 0
 * @default 0
 * 
 * @param op
 * @text Operator
 * @desc Select the type of operation to cast over the value for this Game Variable
 * @type select
 * @option Greater
 * @value greater
 * @option Greater or equal
 * @value greater_equal
 * @option Equal
 * @value equal
 * @option Less or equal
 * @value less_equal
 * @option Less
 * @value less
 * @default equal
 * 
 * @param val
 * @type number
 * @text Value
 * @desc Operate with this value
 * @min 0
 * @default 0
 * 
 * @param target
 * @type boolean
 * @text Value as Variable
 * @desc Map value as a Game Variable which provides the real value. Value must be a valid Game Variable.
 * @default false
 * 
 * @param on
 * @type switch[]
 * @text Game Switch ON
 * @desc define which game switches must be ON for this condition
 *
 * @param off
 * @type switch[]
 * @text Game Switch OFF
 * @desc define which game switches must be OFF for this condition
 *
 */

/**
 * 
 * @returns 
 */
function KunSceneManager() {
    throw `${this.constructor.name} is a Static Class`;
}
/**
 * @returns {String[]}
 */
KunSceneManager.commands = function () {
    return ['KunAnimations'];
};
/**
 * 
 * @returns {KunSceneManager}
 */
KunSceneManager.Initialize = function () {

    var parameters = KunSceneImporter.PluginData();

    //console.log(parameters);

    this._debug = parameters.debug;
    this._fps = parameters.defaultFPS || 10;
    this._touchVar = parameters.touchVarCounter;
    this._limitVar = parameters.touchVarLimit;
    this._touchMode = parameters.touchMode;
    //added as new version to implement external plugin animation packs avoiding overloading the KunAnimationPacks plugin

    this._varX = parameters.touchX;
    this._varY = parameters.touchY;
    this._varWheel = parameters.wheel;
    this._sfx = {
        'touch': parameters.touchSfx || '',
        'cancel': parameters.cancelSfx || '',
        'select': parameters.selectSfx || '',
    };


    this._mode = this.Mode().Disabled;
    this._scenes = {};
    this._labels = {};

    KunSceneImporter.import(parameters.scenes.length ? parameters.scenes : parameters.controllers);

    (Array.isArray(parameters.labels) ? parameters.labels : [])
        .map(tag => tag.split(':'))
        .filter(tag => tag.length > 1)
        .forEach(tag => {
            //console.log(this._labels);
            this._labels[tag[0]] = tag.slice(1).join('|')
        });

    //reset targets
    KunTouch.reset();
};
/**
 * @param {Boolean} list 
 * @returns {Object|String[]}
 */
KunSceneManager.labels = function (list = false) {
    return list ? Object.values(this._labels) : this._labels;
};
/**
 * @returns Object
 */
KunSceneManager.DebugMode = function () {
    return {
        'Disabled': 0,
        'Enabled': 1,
        'TraceLog': 2,
    };
};

/**
 * @returns {Boolean}
 */
KunSceneManager.debug = function (level) {
    if (typeof level === 'number' && level > 0) {
        return this._debug >= level;
    }
    return this._debug > KunSceneManager.DebugMode().Disabled;
};
/**
 * @param {String} sound 
 * @param {Number} round
 * @returns {KunSceneManager}
 */
KunSceneManager.playSound = function (sound, round) {
    if (typeof KunSounds === 'function') {
        KunSounds.play(sound, round);
    }
    return this;
};
/**
 * @param {String} mode 
 * @returns {KunSceneManager}
 */
KunSceneManager.setMode = function (mode) {
    this._mode = mode;
    switch (this._mode) {
        case KunSceneManager.Mode().Capture:
        case KunSceneManager.Mode().Touch:
            this.unlock(true);
            break;
        case KunSceneManager.Mode().Disabled:
        default:
            this.clearTargets().lock();
            break;
    }
    return this;
};
/**
 * @returns Object
 */
KunSceneManager.dump = function () {
    return this;
}
/**
 * @returns {String}
 */
KunSceneManager.sfx = function (name = 'touch') {
    return name.length && this._sfx.hasOwnProperty(name) ? this._sfx[name] : this._sfx.touch;
};
/**
 * @param {Boolean} unlock
 * @returns {KunSceneManager}
 */
KunSceneManager.unlock = function (unlock) {
    if (this._touchMode) {
        $gameSwitches.setValue(this._touchMode, typeof unlock === 'boolean' && unlock);
    }
    return this;
};
/**
 * @returns {KunSceneManager}
 */
KunSceneManager.lock = function () {
    return this.unlock(false);
};
/**
 * @returns {Boolean}
 */
KunSceneManager.locked = function () {
    return this._mode === KunSceneManager.Mode().Disabled;
};
/**
 * Required for clear chaining. Do not remove atm
 * @returns {KunSceneManager}
 */
KunSceneManager.clearTargets = function () {
    KunTouch.clear();
    return this;
};
/**
 * @param {Number} x 
 * @param {Number} y 
 * @returns {KunSceneManager}
 */
KunSceneManager.position = function (x = 0, y = 0) {
    if (this._varX > 0) {
        $gameVariables.setValue(this._varX, x);
    }
    if (this._varY > 0) {
        $gameVariables.setValue(this._varY, y);
    }
    return this;
};
/**
 * @param {Number} value 
 * @returns {KunSceneManager}
 */
KunSceneManager.scroll = function( value = 0 ){
    if( Math.abs(value) > 0 && this._varWheel ){
        const min = 0;
        const max = 8;
        const amount = Math.max( ($gameVariables.value(this._varWheel ) + value / Math.abs(value) ) % max , min);
        $gameVariables.setValue(this._varWheel ,  amount );
        console.log( $gameVariables.value(this._varWheel));
    }
    return this;
};
/**
 * @param {Number} counter 
 * @returns {KunSceneManager}
 */
KunSceneManager.updateTouchPoints = function (counter = 0) {
    if (this._touchVar > 0) {
        $gameVariables.setValue(this._touchVar, counter);
    }
    return this;
};
/**
 * @param {Boolean} gameVar
 * @returns {Number}
 */
KunSceneManager.touchLimit = function (gameVar = false) {
    return gameVar ? this._limitVar : this._limitVar && $gameVariables.value(this._limitVar) || 1;
};
/**
 * @returns {Boolean}
 */
KunSceneManager.canCapture = function () {
    return this.mode() === KunSceneManager.Mode().Capture;
};
/**
 * @returns {Boolean}
 */
KunSceneManager.canTouch = function () {
    return this.mode() === KunSceneManager.Mode().Touch && !this.locked();
};
/**
 * @returns {Boolean}
 */
KunSceneManager.canWheel = function(){
    return this.mode() === KunSceneManager.Mode().Touch && this._varWheel > 0;
};
/**
 * @returns {Boolean}
 */
KunSceneManager.canPlayBack = function () {
    return this.mode() === this.Mode().PlayBack;
};
/**
 * @returns {String}
 */
KunSceneManager.mode = function () {
    return this._mode;
};
/**
 * @returns Number
 */
KunSceneManager.FPS = function () {
    return this._fps || 10;
};
/**
 * @param {Boolean} list
 * @returns {KunPicture[]|Object}
 */
KunSceneManager.scenes = function (list = false) {
    return list ? Object.values(this._scenes) : this._scenes;
};
/**
 * @param {KunPicture} scene 
 * @returns {KunSceneManager}
 */
KunSceneManager.add = function (scene) {
    if (scene instanceof KunPicture && !this.has(scene.name())) {
        this.scenes()[scene.name()] = scene;
    }
    return this;
};
/**
 * @param {String} name 
 * @returns {Boolean}
 */
KunSceneManager.has = function (name = '') {
    return name && this.scenes().hasOwnProperty(name);
}
/**
 * @param {String} name 
 * @returns {KunPicture}
 */
KunSceneManager.scene = function (name = '') {
    return this.has(name) ? this.scenes()[name] : null;
}
/**
 * @param {String} sfx
 * @param {Number} pitch
 * @param {Number} pan
 * @returns {KunSceneManager}
 */
KunSceneManager.playFx = function (sfx, pitch, pan) {
    if (sfx.length) {
        if (typeof pitch !== 'number') {
            pitch = 90 + Math.floor(Math.random() * 20);
        }
        if (typeof pan !== 'number') {
            pan = Math.floor(Math.random() * 20) - 10;
        }
        this.AudioManager(sfx, 100, pitch, pan);
    }
    return this;
};
/**
 * @param {Number} pictureId 
 * @param {String} name 
 * @param {Number} x 
 * @param {Number} y 
 * @param {Number} scaleX 
 * @param {Number} scaleY 
 * @param {Number} opacity 
 * @param {Number} blend 
 * @param {Number} origin
 * @returns {Game_Picture}
 */
KunSceneManager.preparePicture = function (name = '', pictureId = 0, x = 0, y = 0, scaleX = 100, scaleY = 100, opacity = 255, blend = 0, origin = 0) {

    if (name && pictureId) {
        $gameScreen.showPicture(
            pictureId, name,
            origin || 0 , // origin (top-left)
            x, y,
            scaleX, scaleY,
            opacity, blend);

        return $gameScreen.picture(pictureId);
    }

    return null;
};
/**
 * @param {Number} pictureId 
 * @param {String} pictureName 
 * @returns {Game_Picture}
 */
KunSceneManager.replacePicture  =function( pictureId = 0 , pictureName = '' ){
    if( pictureName && pictureId ){

        const original = $gameScreen.picture(pictureId);
        if( original ){

            return this.preparePicture( pictureName , pictureId,
                original.x(),original.y(),
                original.scaleX(),original.scaleY(),
                original.opacity(),original.blendMode(),
                original.origin() );
        }

    }
    return null;
};
/**
 * @returns Object
 */
KunSceneManager.Mode = function () {
    return {
        'Disabled': 'disabled',
        'Touch': 'touch',
        'Capture': 'capture',
        'PlayBack': 'playback',
    };
};
KunSceneManager.Behavior = {
    'Forward': 'forward',
    'Reverse': 'reverse',
    'PingPong': 'ping-pong',
    'Static': 'static',
};

/**
 * 
 * @param {String} se 
 * @param {Number} volume 
 * @param {Number} pitch 
 * @param {Number} pan 
 * @param {Boolean} interrupt
 */
KunSceneManager.AudioManager = function (se, volume, pitch, pan, interrupt = false) {
    if (se.length) {
        if (interrupt) {
            AudioManager.stopSe();
        }
        //KunSceneManager.DebugLog( `Playing ${se} at vol ${volume}, pitch ${pitch} and pan ${pan} ${interrupt}` );
        AudioManager.playSe({ name: se, pan: pan || 0, pitch: pitch || 100, volume: volume || 90 });
    }
};
/**
 * @param {String} message 
 */
KunSceneManager.DebugLog = function (message) {
    if (KunSceneManager.debug()) {
        console.log(typeof message === 'object' ? message : `[ KunSceneManager ] ${message.toString()}`);
    }
};

/**
 * 
 */
function KunSceneImporter() {
    throw `${this.constructor.name} is a Static Class`;
};
/**
 * 
 * @returns {KunSceneImporter}
 */
KunSceneImporter.summary = function () {
    //leave this here for debugging.
    if (KunSceneManager.debug(KunSceneManager.DebugMode().TraceLog)) {
        KunSceneManager.DebugLog(`Imported a total of ${this._pictures} animated pictures, ${this._animations} animation layers and ${this._hotspots} hotspots`);
        KunSceneManager.DebugLog(`Imported a total of ${this._actions} actions and  ${this._conditions} conditions`);
    }
    return this;
};
/**
 * @returns {Object[]}
 */
KunSceneImporter.listAnimationPacks = function () {
    return $plugins.filter(plugin => plugin.name === 'KunAnimationPack' && plugin.status && plugin.parameters.scenes.length > 0).map(plugin => plugin.parameters);
};
/**
 * @returns {Object}
 */
KunSceneImporter.PluginData = function () {

    function _parsePluginData(key, value) {
        if (typeof value === 'string' && value.length) {
            try {
                if (/^\{.*\}$|^\[.*\]$/.test(value)) {
                    return JSON.parse(value, _parsePluginData);
                }
            } catch (e) {
                // If parsing fails or it's not an object/array, return the original value
            }
            if (value === 'true' || value === 'false') {
                return value === 'true';
            }
            if (!isNaN(value)) {
                return parseInt(value);
            }
        }
        else if (typeof value === 'object' && !Array.isArray(value)) {
            var _output = {};
            Object.keys(value).forEach(function (key) {
                _output[key] = _parsePluginData(key, value[key]);
            });
            return _output;
        }
        return value;
    };

    var pluginData = _parsePluginData('KunAnimations', PluginManager.parameters('KunAnimations'));

    if( typeof pluginData.scenes === 'undefined'){
        pluginData.scenes = [];
    }

    this.listAnimationPacks().map(pack => _parsePluginData('KunAnimationPack', pack)).forEach(function (pack) {
        //Import animation packs
        if (pack.scenes.length) {
            KunSceneManager.DebugLog(`Loading Animation Pack ${pack.name} (${pack.scenes.length} scenes)`);
            pack.scenes.forEach(function (scene) {
                pluginData.scenes.push(_parsePluginData('KunAnimationPack', scene));
            });
        }
    });
    return pluginData;
};

/**
 * @param {Object[]} input 
 * @returns {KunSceneManager}
 */
KunSceneImporter.import = function (input) {

    this._scenes = 0;
    this._pictures = 0;
    this._animations = 0;
    this._hotspots = 0;
    this._actions = 0;
    this._conditions = 0;

    if (Array.isArray(input)) {
        input.forEach(function (controller) {
            var pictures = Array.isArray(controller.source) ? controller.source : [];
            var soundLoop = controller.soundLoop || 0;
            var soundProfile = Array.isArray(controller.soundProfile) ? controller.soundProfile : [];
            if (soundProfile.length === 0) {
                //backwards compatibility
                soundProfile = Array.isArray(controller.soundBankPrefix) ? controller.soundBankPrefix : [];
            }
            var spotMap = {};
            //import all scene defined hotspots
            (Array.isArray(controller.hotspots) ? controller.hotspots : []).forEach(function (spot) {
                if (!spotMap.hasOwnProperty(spot.name)) {
                    spotMap[spot.name] = spot;
                }
            });
            //register a Scene Controller on every picture loaded in the list
            for (var i = 0; i < pictures.length; i++) {
                var soundPack = soundProfile.length >= pictures.length ? soundProfile[i] : (soundProfile.length ? soundProfile[0] : '');
                var picture = KunSceneImporter.importScene(
                    pictures[i],
                    controller,
                    soundPack,
                    spotMap,
                    soundLoop);

                KunSceneManager.add(picture);
            }
        });
    }

    return this.summary();
};

/**
 * 
 * @param {String} picture
 * @param {Object} controller
 * @param {String} audioProfile
 * @param {Object} spots
 * @param {Number} soundLoop
 */
KunSceneImporter.importScene = function (picture, controller, audioProfile, spots, soundLoop = 0) {

    var scene = new KunPicture(picture, controller.cols, controller.rows, controller.fps || 0, audioProfile, soundLoop);

    (Array.isArray(controller.framesets) ? controller.framesets : []).forEach(function (frameSet) {
        scene.add(KunSceneImporter.importAnimation(frameSet, spots));
    });

    if (Array.isArray(controller.actions)) {
        controller.actions.forEach(function (action) {
            scene.addAction(KunSceneImporter.importAction(action));
        });
    }

    this._scenes++;
    this._pictures++;

    return scene;
};
/**
 * 
 * @param {Object} frameSet 
 * @param {Object} hotSpots 
 * @returns {KunFrameSet}
 */
KunSceneImporter.importAnimation = function (frameSet, hotSpots) {
    var animation = new KunFrameSet(
        frameSet.name,
        frameSet.type,
        frameSet.fps,
        frameSet.loops,
        Array.isArray(frameSet.next) ? frameSet.next : [],
        Array.isArray(frameSet.bank) ? frameSet.bank : [],
        frameSet.offsetX,
        frameSet.offsetY
    );
    //import frameset
    (Array.isArray(frameSet.frames) ? frameSet.frames : []).forEach(function (frame) {
        animation.add(frame);
    });
    //import conditions
    (Array.isArray(frameSet.conditions) ? frameSet.conditions : []).forEach(function (condition) {
        animation.addCondition(KunSceneImporter.importCondition(condition));
    });
    //merge hotspots into touchspots
    (Array.isArray(frameSet.spots) ? frameSet.spots : []).forEach(function (touchSpot) {
        if (hotSpots.hasOwnProperty(touchSpot.name)) {
            var spot = hotSpots[touchSpot.name];
            Object.keys(spot).forEach(function (key) {
                if (!touchSpot.hasOwnProperty(key)) {
                    touchSpot[key] = spot[key];
                }
            });
            animation.registerSpot(KunSceneImporter.importSpot(touchSpot));
        }
    });

    this._animations++;

    return animation;
};
/**
 * 
 * @param {Object} action 
 * @returns {KunAction}
 */
KunSceneImporter.importAction = function (action) {
    var ac = new KunAction(
        action.var || 0,
        action.op || '',
        action.val,
    );
    //No conditions for Actions atm, use Actions wisely on start/complete and touch-events (might also be in playback)
    /*if( Array.isArray( action.conditions) ){
        action.conditions.forEach( function( condition ){
            action.addCondition( KunSceneImporter.importCondition(condition) );
        });
    }*/
    this._actions++;
    return ac;
};
/**
 * 
 * @param {Object} condition 
 */
KunSceneImporter.importCondition = function (condition) {

    this._conditions++;

    return new KunCondition(
        condition.var || 0,
        condition.op || '',
        condition.val || 0,
        condition.target || false,
        condition.on || [],
        condition.off || []
    );
};
/**
 * @param {Object} spot 
 * @returns {KunHotSpot}
 */
KunSceneImporter.importSpot = function (spot) {
    var touchEvent = new KunHotSpot(
        spot.name,
        spot.x1,
        spot.y1,
        spot.x2,
        spot.y2,
        spot.trigger || KunHotSpot.Trigger.Queue,
        Array.isArray(spot.next) ? spot.next : [],
        spot.sfx
    );
    if (spot.varId > 0) {
        //backwards compatibility.
        touchEvent.addAction(new KunAction(spot.varId, spot.behavior, spot.amount || 1));
    }
    //No actions parameter until next versions, use varId instead for backwards compatibility
    if (Array.isArray(spot.actions)) {
        //map all event actions
        spot.actions.forEach(function (action) {
            //if(spot.trigger)
            //action.tag = spot.trigger;
            touchEvent.addAction(KunSceneImporter.importAction(action));
        });
    }
    if (Array.isArray(spot.conditions)) {
        //map all event conditions
        spot.conditions.forEach(function (condition) {
            touchEvent.addCondition(KunSceneImporter.importCondition(condition));
        });
    }
    this._hotspots++;
    return touchEvent;
};



/**
 * 
 */
function KunTouch() {
    throw `${this.constructor.name} is a Static Class`;
};
/**
 * @returns {KunTouch}
 */
KunTouch.reset = function () {
    this._targets = [];
    return this.lock(false);
};
/**
 * @param {Boolean} lock 
 * @returns {KunTouch}
 */
KunTouch.lock = function (lock = false) {
    this._lock = lock;
    return this;
};
/**
 * @returns {Boolean}
 */
KunTouch.locked = function () {
    return this._lock;
}
/**
 * @returns {KunTarget[]}
 */
KunTouch.targets = function () {
    return this._targets;
};
/**
 * @returns {Number}
 */
KunTouch.count = function () {
    return this.targets().length;
};
/**
 * @returns {Number}
 */
KunTouch.size = function () {
    return KunSceneManager.touchLimit();
};
/**
 * @returns {Boolean}
 */
KunTouch.full = function () {
    return this.count() >= this.size();
};
/**
 * @returns {KunTouch}
 */
KunTouch.drop = function () {
    if (this.count() && !this.locked()) {
        this.lock(true);
        this.targets().shift();
        this.update().lock(false);
        KunSceneManager.playFx(KunSceneManager.sfx('cancel'));
    }
    return this;
};
/**
 * @param {Boolean} random 
 * @returns {KunTarget}
 */
KunTouch.target = function (random = false) {
    if (this.count() && !this.locked()) {
        this.lock(true);
        var target = random ?
            this.targets().splice(Math.floor(Math.random() * this.count()), 1)[0] :
            this.targets().shift();
        this.update().lock(false);
        return target.execute();
        //return target;
    }
    return null;
}
/**
 * @returns {Boolean}
 */
KunTouch.ready = function () {
    return !this.full() && !this.locked();
};
/**
 * @param {KunTarget} target 
 * @returns {KunTouch}
 */
KunTouch.add = function (target) {
    if (target instanceof KunTarget && this.ready()) {
        this.targets().push(target);
        this.update();
        KunSceneManager.playFx(KunSceneManager.sfx('touch'));
    }
    return this;
};
/**
 * @returns {KunTouch}
 */
KunTouch.clear = function () {
    return this.reset().update();
};
/**
 * @returns {KunTouch}
 */
KunTouch.update = function () {
    KunSceneManager.updateTouchPoints(this.count());
    return this;
};

/**
 * @param {String} name 
 * @param {Number} cols 
 * @param {Number} rows 
 * @param {Number} fps 
 * @param {String} soundProfile 
 * @param {Number} soundLoop
 */
function KunPicture(name, cols = 1, rows = 1, fps = 0, soundProfile = '', soundLoop = 0) {

    this._name = name || '';
    this._cols = cols || 1;
    this._rows = rows || 1;
    //this._framesets = {};
    this._framesets = [];
    //this one can be overriden
    this._fps = fps || KunSceneManager.FPS();
    this._audioProfile = soundProfile || '';
    this._audioLoop = soundLoop || 0;
    this._actions = [
        //KunActions
    ];
};
/**
 * @param {Number} pictureID
 * @param {String} alias
 * @param {String} first 
 * @param {Boolean} autoPlay
 * @returns {KunAnimation}
 */
KunPicture.prototype.createAnimation = function (pictureId = 0, alias = '', first = '', autoPlay = false) {
    return new KunAnimation(this, first, autoPlay, pictureId, alias);
};
/**
 * @returns {String}
 */
KunPicture.prototype.toString = function () {
    return this.name();
};
/**
 * @returns {String}
 */
KunPicture.prototype.name = function () {
    return this._name;
};
/**
 * @param {Boolean} list
 * @returns {KunFrameSet[]}
 */
KunPicture.prototype.framesets = function (list = false) {
    return this._framesets;
    return list ? Object.values(this._framesets) : this._framesets;
};
/**
 * @returns {Number}
 */
KunPicture.prototype.cols = function () { return this._cols; }
/**
 * @returns {Number}
 */
KunPicture.prototype.rows = function () { return this._rows; }
/**
 * @returns {Number}
 */
KunPicture.prototype.totalFrames = function () { return this._cols * this._rows; };
/**
 * @param {String} name 
 * @returns {Boolean}
 */
KunPicture.prototype.has = function (name = '') {
    return name && this.framesets().filter(fs => fs.name() === name).length > 0;
}
/**
 * @param {KunFrameSet} frameset 
 * @returns {KunPicture}
 */
KunPicture.prototype.add = function (frameset) {
    if (frameset instanceof KunFrameSet) {
        this.framesets().push(frameset);
        //this.framesets()[frameset.name()] = frameset;
    }
    return this;
};
/**
 * @returns {Boolean}
 */
KunPicture.prototype.empty = function () {
    return this.framesets().length === 0;
    //return this.framesets(true).length === 0;
};
/**
 * @param {String} sound
 * @returns {String}
 */
KunPicture.prototype.soundProfile = function (sound = '') {
    return sound ? this._audioProfile && this._audioProfile + '-' + sound || sound : this._audioProfile;
};
/**
 * @returns {Number}
 */
KunPicture.prototype.soundLoop = function () {
    return this._audioLoop;
};
/**
 * @returns {Number}
 */
KunPicture.prototype.fps = function () {
    return this._fps || KunSceneManager.FPS();
};
/**
 * @param {KunAction} action
 * @returns {KunPicture}
 */
KunPicture.prototype.addAction = function (action, tag = '') {
    if (action instanceof KunAction) {
        this._actions.push(action.tag(tag));
    }
    return this;
};
/**
 * @param {String} tag
 * @returns {KunAction[]}
 */
KunPicture.prototype.actions = function (tag = '') {
    return tag ? this._actions.filter(action => action.is(tag)) : this._actions;
};
/**
 * @param {String} tag
 * @returns {KunPicture}
 */
KunPicture.prototype.runActions = function (tag = '') {
    this.actions(tag).forEach(action => action.update());
    return this;
};




/**
 * @param {String} name 
 * @param {String} type 
 * @param {Number} fps 
 * @param {Number} loops 
 * @param {String} next 
 * @param {String[]|String} sounds
 * @param {Number} offsetX
 * @param {Number} offsetY
 */
function KunFrameSet(name, type = KunSceneManager.Behavior.Default, fps = 0, loops = 0, next = [], sounds = [], offsetX = 0, offsetY = 0) {
    this._name = name.toLowerCase().replace(/[\s\_]/, '-');
    this._fps = typeof fps === 'number' && fps > 0 ? fps : 0;
    this._frames = [];
    this._type = type || KunSceneManager.Behavior.Default;
    this._loops = loops || 0;
    this._offsetX = offsetX || 0;
    this._offsetY = offsetY || 0;
    this._spots = {
        //interactive spots to touch
    };

    this._next = Array.isArray(next) ? next : (typeof next === 'string' && next.length ? [next] : []);
    this._sounds = Array.isArray(sounds) ? sounds : (typeof sounds === 'string' && sounds.length ? [sounds] : []);

    this._conditions = [
        //KunConditions
    ];
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.offsetX = function () {
    return this._offsetX;
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.offsetY = function () {
    return this._offsetY;
};
/**
 * @returns {Boolean}
 */
KunFrameSet.prototype.interactive = function () {
    return this.spots(true).length > 0;
};
/**
 * @param {KunHotSpot} spot 
 * @returns {KunFrameSet}
 */
KunFrameSet.prototype.registerSpot = function (spot) {

    if (spot instanceof KunHotSpot && !this._spots.hasOwnProperty(spot.name())) {
        //
        this._spots[spot.name()] = spot;
    }

    return this;
};
/**
 * List all spots as array or object ids
 * @param {Boolean} list 
 * @returns {Object | KunHotSpot[]}
 */
KunFrameSet.prototype.spots = function (list = false) {
    return list ? Object.values(this._spots) : this._spots;
}
/**
 * @param {String} spot 
 * @returns {Boolean}
 */
KunFrameSet.prototype.hasSpot = function (spot = '') {
    return spot.length && this.spots().hasOwnProperty(spot);
}
/**
 * @param {String} spot 
 * @returns {KunHotSpot}
 */
KunFrameSet.prototype.getSpot = function (spot) {
    return this.hasSpot(spot) ? this.spots()[spot] : null;
}
/**
 * Check if any spot was touched
 * @param {Number} x 
 * @param {Number} y 
 * @returns {KunHotSpot} 
 */
KunFrameSet.prototype.touchSpot = function (x, y) {
    const hotspots = this.spots(true).filter(spot => spot.unlocked() && spot.touched(x, y));
    return hotspots.length ? hotspots[0] : null;
    for (var i in hotspots) {
        //hotspots[i].test( x , y );
        if (hotspots[i].touched(x, y)) {
            //console.log( `${hotspots[i]} touched on ${x},${y}` );
            return hotspots[i];
        }
    }
    return null;
};
/**
 * @returns {String}
 */
KunFrameSet.prototype.behavior = function () {
    return this._type;
};
/**
 * @param {Number} frame 
 * @returns {KunFrameSet}
 */
KunFrameSet.prototype.add = function (frame) {
    this._frames.push(frame);
    return this;
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.fps = function () {
    return this._fps;
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.loops = function () {
    return this._loops;
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.frames = function () {
    return this._frames.length > 0 ? this._frames : [0];
}
/**
 * @returns {Number}
 */
KunFrameSet.prototype.first = function () {
    return this.frames().length > 0 ? this.frames()[0] : 0;
};
/**
 * @param {Number} index 
 * @returns {Number}
 */
KunFrameSet.prototype.frame = function (index = 0) {
    return this._frames.length > index ? this._frames[index] : this._frames[0];
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.count = function () {
    return this.frames().length;
};
/**
 * @returns {Number}
 */
KunFrameSet.prototype.name = function () {
    return this._name;
};
/**
 * @returns {String[]}
 */
KunFrameSet.prototype.next = function () {
    return this._next;
};
/**
 * @param {Boolean} select
 * @returns {String[]|String}
 */
KunFrameSet.prototype.getNext = function (select = false) {
    if (select) {
        var size = this._next.length;
        return size ? this._next[Math.floor(Math.random() * size)] : '';
    }
    return this._next;
}
/**
 * @param {Boolean} select
 * @returns {String[]|String}
 */
KunFrameSet.prototype.sounds = function (select = false) {
    var size = this._sounds.length;
    if (select) {
        //always return a string with a select flag!
        return size ? this._sounds[Math.floor(Math.random() * size)] : '';
    }
    return this._sounds;
};
/**
 * @param {KunCondition} condition
 * @returns {KunFrameSet}
 */
KunFrameSet.prototype.addCondition = function (condition) {
    if (condition instanceof KunCondition) {
        this._conditions.push(condition);
    }
    return this;
};
/**
 * @param {Boolean} filter
 * @returns {KunCondition[]}
 */
KunFrameSet.prototype.conditions = function (filter = false) {
    return filter ?
        this._conditions.filter(condition => condition.validate()) :
        this._conditions;
};
/**
 * @returns {Boolean}
 */
KunFrameSet.prototype.unlocked = function () {
    return this.conditions(true).length === this.conditions().length;
};
/**
 * 
 * @returns 
 */
KunFrameSet.prototype.randomSpot = function () {
    var list = this.spots(true);
    return list.length > 0 ? list[Math.floor(Math.random() * list.length)] : null;
};


/**
 * @param {KunPicture} scene 
 * @param {String} animation
 * @param {Boolean} autoPlay
 * @param {Number} pictureId
 * @param {String} alias
 */
function KunAnimation(scene, animation = '', autoPlay = false, pictureId = 0, alias = '') {

    this._scene = scene instanceof KunPicture ? scene : null;
    this._frameset = this.get(animation) || this.first();

    this.setAlias(alias || '');
    this.setID(pictureId || 0);

    this._playing = autoPlay || false;

    this._elapsed = 0;
    this._backwards = false;
    this._frame = 0;

    //this one can be overriden
    this._variant = 0;
    this._loop = 0;
    this._fps = 0;

    this._playList = [];

    this._stages = {};

    this.reset();
}
/**
 * @param {Boolean} list 
 * @returns {String[]|Object}
 */
KunAnimation.prototype.stages = function( list = false ){
    return list ? Object.keys(this._stages ) : this._stages;
};
/**
 * @param {String} stage 
 * @returns {KunPicture}
 */
KunAnimation.prototype.stage = function( stage = '' ){
    return KunSceneManager.scene(this.stages()[stage] || '' );
};
/**
 * @param {String} stage 
 * @param {String} picture 
 * @returns {KunPicture}
 */
KunAnimation.prototype.addStage = function( stage = '' , picture= '' ){
    if( stage && !this.stages().hasOwnProperty(stage) && KunSceneManager.has(picture)){
        this.stages()[stage] = picture;
    }
    return this;
};
/**
 * @param {Boolean} list 
 * @returns {String[]}
 */
KunAnimation.prototype.labels = function (list = false) {
    return KunSceneManager.labels(list);
}
/**
 * @returns {Object}
 */
KunAnimation.prototype.mapAnimationLabels = function () {
    const labels = {};
    this.animations()
        .map(a => a.name())
        .forEach(animation => labels[animation] = this.labels().hasOwnProperty(animation) ? this.labels()[animation] : animation);
    return labels;
}
/**
 * @returns {Object}
 */
KunAnimation.prototype.mapSpotLabels = function () {
    const labels = {};
    const spots = this.frameset() && this.frameset().spots(true) || [];
    spots.map(spot => spot.name())
        .forEach(spot => labels[spot] = this.labels().hasOwnProperty(spot) ? this.labels()[spot] : spot);
    return labels;
};
/**
 * @returns {Object}
 */
KunAnimation.prototype.mapStages = function(){
    const labels = {};
    const stages = this.stages(true);
    stages.forEach( stage => labels[stage] = this.labels().hasOwnProperty(stage) ? this.labels()[stage] : stage );
    return labels;
};
/**
 * @param {String} type 
 * @returns {Object}
 */
KunAnimation.prototype.mapMenu = function( type = 'spot' ){
    switch( type ){
        case 'stage':
            return this.mapStages();
        case 'animation':
            return this.mapAnimationLabels();
        case 'touch':
        case 'capture':
        default:
            return this.mapSpotLabels();
    }
};
/**
 * @param {String} tag 
 * @returns {KunAnimation}
 */
KunAnimation.prototype.runActions = function (tag = '') {
    if (this.scene()) {
        this.scene().runActions(tag);
    }
    return this;
};
/**
 * @param {String} alias 
 * @returns {KunAnimation}
 */
KunAnimation.prototype.setAlias = function (alias = '') {
    this._alias = alias || '';
    return this;
};
/**
 * @param {String} animation 
 * @returns {KunAnimation}
 */
KunAnimation.prototype.push = function (animation) {
    this._playList.push(animation);
    return this;
};
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.clear = function (animation = '') {
    this._playList = animation ? this._playList.filter(a => a !== animation) : [];
    return this;
};
/**
 * @returns {String[] }
 */
KunAnimation.prototype.playList = function () {
    return this._playList.length ? this._playList : this.next();
};
/**
 * @returns {String[]}
 */
KunAnimation.prototype.list = function () {
    return this.scene() && this.scene().framesets(true).map(fs => fs.name()) || [];
};
/**
 * @returns {Number}
 */
KunAnimation.prototype.rows = function () {
    return this.scene() && this.scene().rows() || 0;
};
/**
 * @returns {Number}
 */
KunAnimation.prototype.cols = function () {
    return this.scene() && this.scene().cols() || 0;
};
/**
 * @returns {Number}
 */
KunAnimation.prototype.frame = function () {
    return this.frameset() && this.frameset().frame(this._frame) || 0;
};
/**
 * @param {Number} x 
 * @param {Number} y 
 * @returns {KunHotSpot}
 */
KunAnimation.prototype.touch = function (x, y) {
    return this.frameset() && this.frameset().touchSpot(x, y) || null;
};
/**
 * @returns {KunHotSpot}
 */
KunAnimation.prototype.randomSpot = function () {
    const spots = this.frameset().spots(true);
    return spots.length ? spots[Math.floor(Math.random() * spots.length)] : null;
};
/**
 * @param {KunHotSpot} spot 
 * @param {Number} x 
 * @param {Number} y 
 * @returns {KunAnimation}
 */
KunAnimation.prototype.target = function (spot, x, y) {
    if (spot instanceof KunHotSpot) {
        switch (spot.trigger()) {
            case KunHotSpot.Trigger.Queue:
                KunTouch.add(new KunTarget(spot, this.name(), x, y, this.ID()));
                break;
            case KunHotSpot.Trigger.Instant:
                spot.update().touchSfx();
                KunSceneManager.position(x, y);
                this.select(spot.next());
                break;
            case KunHotSpot.Trigger.Frame:
                var frame = this.frameset().frame();
                spot.actions().forEach(action => action.set(frame));
                spot.touchSfx();
                break;
            case KunHotSpot.Trigger.NextFrame:
                this.select(spot.next());
                if (this.frameset()) {
                    //KunSceneManager.DebugLog('NextFrame Touched: ' + next.first());
                    const first = this.frameset().first();
                    spot.actions().forEach(action => action.set(first));
                    spot.touchSfx();
                }
                break;
        }
    }
    return this;
};
/**
 * @param {String} target
 * @param {Boolean} touchEffect
 * @returns {KunAnimation}
 */
KunAnimation.prototype.capture = function (target = 'random', touchEffect = false) {
    const spot = target === 'random' ? this.randomSpot() : this.frameset().spots()[target] || null;
    const pictures = $gameScreen._pictures.filter(picture => picture && picture._name === this.name());
    if (spot && pictures.length > 0) {
        const px = pictures[0]._x + Math.floor(pictures[0]._scaleX / 100 * spot.getPosX(true));
        const py = pictures[0]._y + Math.floor(pictures[0]._scaleY / 100 * spot.getPosY(true));
        KunSceneManager.DebugLog(`${this.name()}: ${px},${py} (${pictures[0]._x},${pictures[0]._y})`);
        if (touchEffect) {
            this.target(spot, px, py);
        }
        else {
            KunSceneManager.position(px, py);
        }
    }
    return this;
};
/**
 * @param {String} name 
 * @returns {Object {X,Y}}
 */
KunAnimation.prototype.offset = function () {
    const animation = this.frameset();
    return {
        'x': animation && animation.offsetX(),
        'y': animation && animation.offsetY(),
    };
};
/**
 * @returns {String[]}
 */
KunAnimation.prototype.next = function () {
    return this.frameset() && this.frameset().next() || [];
};
/**
 * @param {String} name
 * @returns {KunAnimation}
 */
KunAnimation.prototype.play = function (name = '') {

    if (name) {
        //&& this.animations().map( anim => anim.name()).includes(animation)
        const frameset = this.get(name, true);
        if (frameset) {
            this._frameset = frameset;
            this.reset();
        }
    }

    this._playing = this.frameset() !== null;

    return this;
}
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.stop = function () {
    this._playing = false;
    return this;
}
/**
 * @returns {Boolean}
 */
KunAnimation.prototype.playing = function () {
    return this._playing && this.ready();
};
/**
 * @returns {Number}
 */
KunAnimation.prototype.ID = function () {
    return this._pictureId;
};
/**
 * @return {KunAnimation}
 */
KunAnimation.prototype.setID = function( pictureId = 0 ){
    this._pictureId = pictureId || 0;
    return this;
};
/**
 * @param {Boolean} useAlias 
 * @returns {String}
 */
KunAnimation.prototype.name = function (useAlias = false) {
    return useAlias && this._alias ? this.alias() : this.scene().name();
};
/**
 * @returns {String}
 */
KunAnimation.prototype.alias = function(){
    return this._alias;
};
/**
 * @returns {Number}
 */
KunAnimation.prototype.fps = function () {
    return this._fps || KunSceneManager.FPS();
};
/**
 * @param {Number} fps
 * @param {Number} rate
 * @returns {KunAnimation} 
 */
KunAnimation.prototype.setFps = function (fps = 0, rate = 0) {
    this._fps = fps || KunSceneManager.FPS();
    this._fpsRate = rate;
    return this;
};
/**
 * @returns {Boolean}
 */
KunAnimation.prototype.ready = function () {
    return this.scene() !== null;
}
/**
 * @returns {KunPicture}
 */
KunAnimation.prototype.scene = function () {
    return this._scene;
};
/**
 * 
 * @param {Number} loop
 * @returns {KunAnimation}
 */
KunAnimation.prototype.sound = function (loop = 0) {
    if (this.frameset() && this.soundLoop(loop)) {
        var sound = this.scene().soundProfile(this.frameset().sounds(true));
        KunSceneManager.playSound(sound);
    }
    return this;
};
/**
 * @param {String} filter
 * @return {KunFrameSet[]}
 */
KunAnimation.prototype.animations = function (filter = '') {
    return this.ready() ? filter && this.scene().framesets().filter(fs => fs.name() === filter) || this.scene().framesets() : [];
    //return this.ready() ? this.scene().framesets(true) : []
}
/**
 * @returns {KunFrameSet}
 */
KunAnimation.prototype.first = function () {
    return this.animations()[0] || null;
};
/**
 * @returns {Boolean}
 */
KunAnimation.prototype.interactive = function () {
    return this.frameset() && this.frameset().interactive();
};
/**
 * @param {String} name 
 * @param {Boolean} random
 * @returns {KunFrameSet}
 */
KunAnimation.prototype.get = function (name = '', random = false) {
    const list = this.animations(name);
    return list.length ? random && list[Math.floor(Math.random() * list.length)] || list[0] : null;
    //return this.scene().has(frameSet) ? this.scene().framesets()[frameSet] : null;
};
/**
 * @param {String[]} animation
 * @returns {KunAnimation}
 */
KunAnimation.prototype.select = function (list = []) {
    const animations = list.length ? this.animations().filter(a => list.includes(a.name()) && a.unlocked()).map(a => a.name()) : [];
    const selected = animations.length ? animations[Math.floor(Math.random() * animations.length)] : '';
    if (selected) {
        this.play(selected);
    }
    return this;
};
/**
 * @returns {KunFrameSet}
 */
KunAnimation.prototype.frameset = function () {
    return this._frameset || null;
};
/**
 * @param {Number} loop 
 * @returns {Boolean}
 */
KunAnimation.prototype.soundLoop = function (loop = 0) {
    const soundLoop = this.scene() && this.scene().soundLoop() || 0;
    return soundLoop ? loop % soundLoop === 0 : true;
};
/** 
 * @returns {Number}
 */
KunAnimation.prototype.count = function () {
    return this.frameset() && this.frameset().count() || 0;
}
/**
 * @returns {Boolean}
 */
KunAnimation.prototype.loop = function () {
    if (this._loop > 0) {
        this._loop--;
        this.sound(this._loop);
    }
    return this._loop === 0;
}
/**
 * @param {Number} amount 
 * @returns {Number}
 */
KunAnimation.prototype.variant = function (amount) {
    if (this._variant) {
        const value = amount * this._variant / 100;
        return amount + Math.floor(Math.random() * value - Math.random() * value);
    }
    return amount;
};
/**
 * @param {Number} variant 
 * @returns {KunAnimation}
 */
KunAnimation.prototype.setVariant = function (variant = 0) {
    this._variant = variant;
    return this;
};
/**
 * @returns {Boolean}
 */
KunAnimation.prototype.tick = function () {
    this._elapsed = ++this._elapsed % this.fps();
    return this._elapsed === 0;
};
/**
 * @param {Boolean } stop
 * @returns {KunAnimation}
 */
KunAnimation.prototype.reset = function (stop = false) {
    this._loop = this.variant(this.frameset().loops());
    this._fps = this.variant(this.frameset().fps() || this.scene().fps());
    this._backwards = false;
    switch (this.frameset().behavior()) {
        case KunSceneManager.Behavior.Reverse:
            this._backwards = true;
            this._frame = this.count() - 1;
            break;
        case KunSceneManager.Behavior.Forward:
            break;
        case KunSceneManager.Behavior.PingPong:
            break;
        case KunSceneManager.Behavior.Static:
            break;
    }
    return stop ? this.stop() : this.sound();
}
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.update = function () {
    if (this.playing() && this.tick()) {
        switch (this.frameset().behavior()) {
            case KunSceneManager.Behavior.PingPong:
                return this.playPingPong();
            case KunSceneManager.Behavior.Reverse:
                return this.playBackward();
            case KunSceneManager.Behavior.Forward:
                return this.playForward();
            case KunSceneManager.Behavior.Static:
            default:
                //do not change
                break;
        }
    }
    return this;
};
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.playPingPong = function () {
    if (this._backwards) {
        //reverse
        this._frame = Math.max(--this._frame, 0);
    }
    else {
        if (++this._frame >= this.count() - 1) {
            this._backwards = true;
        }
    }
    //after complete the round
    if (this._backwards && this._frame === 0) {
        this._backwards = false;
        if (this.loop()) {
            return this.select(this.playList());
        }
    }
    return this;
}
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.playBackward = function () {
    this._frame = Math.max(--this._frame, 0);
    if (this._frame === 0) {
        if (this.loop()) {
            return this.select(this.playList());
        }
        this._frame = this.count() - 1;
    }
    return this;
}
/**
 * @returns {KunAnimation}
 */
KunAnimation.prototype.playForward = function () {
    this._frame = ++this._frame % this.count();
    //check this conditiojn first, then update index, also run when index points to last frame.
    if (this._frame === 0) {
        if (this.loop()) {
            return this.select(this.playList());
        }
    }
    return this;
}

/**
 * 
 * @param {String} name 
 * @param {Number} x1 
 * @param {Number} y1 
 * @param {Number} x2 
 * @param {Number} y2 
 * @param {String} trigger
 * @param {String} next
 * @param {String} sfx
 */
function KunHotSpot(name, x1, y1, x2, y2, trigger = '', next = [], sfx = '') {

    this._name = name;
    this._x1 = parseInt(x1);
    this._y1 = parseInt(y1);
    this._x2 = parseInt(x2);
    this._y2 = parseInt(y2);
    this._trigger = trigger || KunHotSpot.Trigger.Instant;
    this._sfx = sfx || '';
    this._next = Array.isArray(next) && next || [];

    this._conditions = [
        //KunCondions
    ];
    this._actions = [
        //KunActions
    ];
}
/**
 * @returns {String}
 */
KunHotSpot.prototype.toString = function () {
    return this.name();
    //return `${this.name()} (${this._x1} ${this._y1} ${this._x2} ${this._y2})`;
}
/**
 * @returns {String}
 */
KunHotSpot.prototype.name = function () {
    return this._name;
};
/**
 * @param {Boolean} random 
 * @returns {Number}
 */
KunHotSpot.prototype.getPosX = function (random = false) {
    return random ? this._x1 + Math.floor(Math.random() * (this._x2 - this._x1)) : this._x1;
};
/**
 * @param {Boolean} random 
 * @returns {Number}
 */
KunHotSpot.prototype.getPosY = function (random = false) {
    return random ? this._y1 + Math.floor(Math.random() * (this._y2 - this._y1)) : this._y1;
};
/**
 * @returns {String[]}
 */
KunHotSpot.prototype.next = function () {
    return this._next;
};
/**
 * @returns Number
 */
KunHotSpot.prototype.amount = function () {
    return this._amount;
};
/**
 * @returns {String}
 */
KunHotSpot.prototype.behavior = function () {
    return this._behavior;
};
/**
 * @returns {String}
 */
KunHotSpot.prototype.trigger = function () {
    return this._trigger;
};
/**
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.touchSfx = function () {
    if (this._sfx.length) {
        KunSceneManager.playFx(this._sfx);
    }
    return this;
}
KunHotSpot.prototype.setValue = function (value) {
    if (this._varId > 0) {
        $gameVariables.setValue(this._varId, value);
    }
    return this;
};
/**
 * @deprecated Use runActions instead
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.update = function () {
    return this.runActions();
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns 
 */
KunHotSpot.prototype.touched = function (x, y) {
    return (this._x1 <= x && this._x2 >= x) && (this._y1 <= y && this._y2 >= y);
};
/**
 * @returns {Number[]}
 */
KunHotSpot.prototype.area = function () {
    return [this._x1, this._y1, this._x2, this._y2];
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.test = function (x, y) {
    KunSceneManager.DebugLog(`${this.name()} X(${this._x1} >= ${x} <= ${this._x2}) Y(${this._y1} >= ${y} <= ${this._y2})`);
    return this;
};
/**
 * @param {KunCondition} condition
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.addCondition = function (condition) {
    if (condition instanceof KunCondition) {
        this._conditions.push(condition);
    }
    return this;
};
/**
 * @param {Boolean} filter
 * @returns {KunCondition[]}
 */
KunHotSpot.prototype.conditions = function (filter = false) {
    return typeof filter === 'boolean' && filter ?
        this._conditions.filter(condition => condition.validate()) :
        this._conditions;
};
/**
 * @returns {Boolean}
 */
KunHotSpot.prototype.unlocked = function () {
    return this.conditions(true).length === this.conditions().length;
};
/**
 * @param {KunAction} action
 * @param {String} tag
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.addAction = function (action, tag = '') {
    if (action instanceof KunAction) {
        this._actions.push(action.tag(tag));
    }
    return this;
};
/**
 * @param {String} tag
 * @returns {KunAction[]}
 */
KunHotSpot.prototype.actions = function (tag = '') {
    return tag ? this._actions.filter(action => action.is(tag)) : this._actions;
};
/**
 * @param {String} tag
 * @returns {KunHotSpot}
 */
KunHotSpot.prototype.runActions = function (tag = '') {
    this.actions(tag).forEach(action => action.update());
    return this;
};

/**
 * 
 */
KunHotSpot.Trigger = {
    'Instant': 'instant',
    'Queue': 'queue',
    'Ignore': 'ignore',
    'Frame': 'frame',
    'NextFrame': 'next',
};


/**
 * @type {KunTarget}
 * @class {KunTarget}
 */
class KunTarget{
    constructor(spot = null, picture = '', x = 0, y = 0, pictureID = 0){
        this._spot = spot instanceof KunHotSpot ? spot : null;
        this._picture = picture || '';
        this._pictureId = pictureID || 0;
        this._x = x || 0;
        this._y = y || 0;
    }
    /**
     * @returns {String}
     */
    toString() {
        return this.picture() + '.' + this.spot().toString();
    };
    /**
     * @returns {String}
     */
    picture() {
        return this._picture;
    };
    /**
     * @returns {KunAnimation}
     */
    animation() {
        return KunPlayList.get(this.picture());
    };
    /**
     * @returns {KunHotSpot}
     */
    spot() {
        return this._spot;
    };
    /**
     * @returns {Number}
     */
    x() {
        return this._x;
    };
    /**
     * @returns {Number}
     */
    y() {
        return this._y;
    };
    /**
     * @returns {Number}
     */
    ID() {
        return this._pictureId;
    };
    /**
     * @returns {KunTarget}
     */
    position() {
        KunSceneManager.position(this.x(), this.y());
        return this;
    };
    /**
     * @returns {KunTarget}
     */
    execute() {
        if (this.valid()) {
            var animation = this.animation();
            if (animation && animation.ready()) {
                //export X and Y positions, then run actions
                this.position().spot().runActions();
                //jump to next frameset (if any)
                animation.select(this.spot().next());
            }
        }
        return this;
    };
    /**
     * @returns {Boolean}
     */
    valid() {
        return this.spot() && this.picture() && KunSceneManager.has(this.picture());
    };    
}


/**
 * @class {KunCondition}
 * @type {KunCondition}
 */
class KunCondition{
    /**
     * 
     * @param {Number} variable 
     * @param {String} operation 
     * @param {Number} value 
     * @param {Boolean} valueAsVar 
     * @param {Number[]} on 
     * @param {Number[]} off 
     */
    constructor( variable , operation , value = 0, valueAsVar = false , on = [], off = []){
        this._variable = typeof variable === 'number' && variable > 0 ? variable : 0;
        this._operator = typeof operation === 'string' && operation.length > 0 ? operation : KunCondition.Operators().Equal;
        this._value = typeof value === 'number' && value > 0 ? value : 0;
        //define if value targets a game Variable
        this._targetVar = valueAsVar || false;
        //required switches ON and OFF
        this._switchOn = Array.isArray(on) ? on : [];
        this._switchOff = Array.isArray(off) ? off : [];    
    }
    /**
     * @returns {Number}
     */
    targetVar(){
        return this._targetVar && this._value > 0;
    }
    /**
     * @returns {Number}
     */
    value(){
        return this.targetVar() ? $gameVariables.value(this._value) : this._value;
    }
    /**
     * @param {Boolean} getValue 
     * @returns {Number}
     */
    variable( getValue = false ){
        return  getValue && $gameVariables.value(this._variable) || this._variable;
    }
    /**
     * @returns {String}
     */
    operator(){
        return this._operator;
    }
    /**
     * @param {Boolean} listValues 
     * @returns {Number[],Boolean[]}
     */
    on( listValues = false ){
        return listValues ? this._switchOn.map(sw => $gameSwitches.value(sw)) : this._switchOn;
    }
    /**
     * @param {Boolean} listValues 
     * @returns {Number[],Boolean[]}
     */
    off( listValues = false ){
        return listValues ? this._switchOff.map(sw => $gameSwitches.value(sw)) : this._switchOff;
    }
    /**
     * @returns {Boolean}
     */
    validate(){
        if (this.variable() > 0) {
            //validate variable
            switch (this.operator()) {
                case KunCondition.Operators.Greater:
                    return this.variable(true) > this.value();
                case KunCondition.Operators.GreaterOrEqual:
                    return this.variable(true) >= this.value();
                case KunCondition.Operators.Equal:
                    return this.variable(true) = this.value();
                case KunCondition.Operators.LessOrEqual:
                    return this.variable(true) <= this.value();
                case KunCondition.Operators.Less:
                    return this.variable(true) < this.value();
            };
        }
        if (this.on(true).filter(val => !val).length > 0) {
            //count all switched OFF required switches
            return false;
        }
        if (this.off(true).filter(val => val).length > 0) {
            //count all switched ON required switches
            return false;
        }
        return true;        
    }
}
/**
 * 
 */
KunCondition.Operators = {
    'Greater': 'greater',
    'GreaterOrEqual': 'greater_equal',
    'Equal': 'equal',
    'LessOrEqual': 'less_equal',
    'Less': 'less',
};

/**
 * @class {KunAction}
 * @type {KunAction}
 */
class KunAction{
    /**
     * @param {Number} variable 
     * @param {String} operation 
     * @param {Number} value 
     */
    constructor( variable , operation = KunAction.Operators.Add , value = 0){
        this._variable = variable || 0;
        this._operation = operation && operation || KunAction.Operators.Add;
        this._value = value || 0;
        this._tag = [];
    }
    /**
     * @returns {String}
     */
    operation(){
        return this._operation;
    }
    /**
     * @param {Boolean} asValue 
     * @returns {Number}
     */
    variable( asValue = false ){
        return asValue ? $gameVariables.value(this._variable) : this._variable;
    }
    /**
     * @returns {Number}
     */
    value(){
        return this._value;
    }
    /**
     * @param {Number} value 
     * @returns {KunAction}
     */
    set( value = 0 ){
        if (this.variable() > 0) {
            $gameVariables.setValue(this.variable(), value);
        }
        return this;        
    }
    /**
     * @returns {KunAction}
     */
    update(){
            const amount = this.value();
            const current = this.variable(true);
            if (amount > 0) {
                switch (this.operation()) {
                    case KunAction.Operators.Increase: //backwards compatibility
                    case KunAction.Operators.Add:
                        this.set(current + amount);
                        break;
                    case KunAction.Operators.Sub:
                        this.set(current - amount > 0 ? current - amount : 0);
                        break;
                    case KunAction.Operators.Set:
                        this.set(amount);
                        break;
                }
            }
            return this;
    }
    /**
     * @param {String} tag 
     * @returns {Boolean}
     */
    is( tag = ''){
        return (tag.length + this.tags().length === 0) || this.tags().includes(tag);
    }
    /**
     * @param {String} tag 
     * @returns {KunAction}
     */
    tag( tag = ''){
        this._tag = tag.length ? tag.split(' ') : [];
        return this;
    }
    /**
     * @returns {String[]}
     */
    tags(){
        return this._tag;
    }
}
/**
 * 
 */
KunAction.Operators = {
    'Increase': 'increase', //backwards compatibility
    'Add': 'add',
    'Sub': 'sub',
    'Set': 'set',
};


/**
 * 
 * @returns 
 */
function KunPlayList() {
    throw `${this.constructor.name} is a Static Class`;
}
/**
 * @param {String} name 
 * @param {Number} pictureId 
 * @param {String} alias 
 * @param {String} frameset 
 * @returns {KunAnimation}
 */
KunPlayList.setup = function (name = '', pictureId = 0, alias = '', frameset = '') {
    if (KunSceneManager.has(name)) {
        const animation = this.animations()[name] || KunSceneManager.scene(name).createAnimation(pictureId, alias, frameset, frameset.length > 0);
        if( animation ){
            if( alias ){
                //do not remove other animations yet, but ensure they're not using this alias anymore
                this.animations(true).filter( anim => anim.alias() === alias ).forEach( anim => anim.setAlias() );
                animation.setAlias(alias);
            }
            if( pictureId ){
                animation.setID(pictureId);
            }
            this.add(animation);
            return animation;
        }
    }
    return null;
};
/**
 * @param {String} name 
 * @param {String} stage 
 * @returns {KunPlayList}
 */
KunPlayList.setstage = function( name = '', stage = '' , reset = false ){
    const animation = this.get(name);
    if( animation && animation.stages()[stage]){
        const picture = animation.stages()[stage]
        const frameset = animation.frameset() && animation.frameset().name() || '';
        const newanimation = this.setup( picture , animation.ID() , animation.alias(), !reset && frameset || '' );
        //copy all stages into the new animation
        newanimation._stages = animation._stages;
        KunSceneManager.replacePicture( animation.ID() , picture );
    }  
    return this;
};
/**
 * @param {Boolean} list 
 * @returns {Object|KunAnimation[]}
 */
KunPlayList.animations = function (list = false) {
    if (!this.hasOwnProperty('_playList')) {
        //this._playList = {};
        this.reset();
    }
    return list && Object.values(this._playList) || this._playList;
};
/**
 * @param {String} alias 
 * @returns {String}
 */
KunPlayList.alias = function (alias = '') {
    return this.animations(true).filter(a => a.name(true) === alias).map(a => a.name())[0] || alias;
};
/**
 * @param {String} animation 
 * @param {Boolean} useAlias
 * @returns {Boolean}
 */
KunPlayList.has = function (animation = '', useAlias = false) {
    return this.animations().hasOwnProperty(useAlias ? this.alias(animation) : animation);
};
/**
 * @param {String} animation 
 * @returns {KunAnimation}
 */
KunPlayList.get = function (animation = '') {
    return this.animations()[this.alias(animation)] || null;
};
/**
 * @param {KunAnimation} animation 
 * @returns {KunPlayList}
 */
KunPlayList.add = function (animation = null) {
    if (animation instanceof KunAnimation && !this.has(animation.name())) {
        this.animations()[animation.name()] = animation;
    }
    return this;
}
/**
 * @param {String} animation 
 * @returns {String[]}
 */
KunPlayList.list = function (animation = '') {
    const scene = this.get(animation);
    return scene && scene.playList() || [];
};
/**
 * @param {String} animation 
 * @param {String[]} list 
 * @returns {KunPlayList}
 */
KunPlayList.push = function (animation = '', list = []) {
    if (this.has(animation, true)) {
        this.get(animation).push(list);
    }
    return this;
};
/**
 * @param {String} picture 
 * @param {String} animation
 * @returns {KunPlayList}
 */
KunPlayList.play = function (picture = '', animation = '') {
    if (this.has(picture, true)) {
        this.get(picture).play(animation);
    }
    return this;
};
/**
 * @param {String} name 
 * @returns {KunPlayList}
 */
KunPlayList.clear = function (name = '', frameset = '') {
    const animation = this.get(name);
    if (animation) {
        animation.clear(frameset);
    }
    return this;
};
/**
 * @param {String} name 
 * @returns {KunPlayList}
 */
KunPlayList.reset = function (name = '') {
    if (name) {
        const animation = this.get(name);
        if( animation ){
            delete this.animations()[animation.name()];
        }
    }
    else {
        this._playList = {};
    }
    return this;
};
/**
 * @param {String} animation 
 * @param {Number} fps 
 * @returns {KunPlayList}
 */
KunPlayList.setFps = function (animation = '', fps = 0) {
    const scene = this.get(animation);
    if (scene) {
        scene.setFps(fps);
    }
    return this;
};
/**
 * Gets a random spot from the playbacks' active scene animation.
 * @param {String} animation 
 * @param {String} spot
 * @returns {KunHotSpot}
 */
KunPlayList.spot = function (animation, spot = 'random') {
    const scene = this.get(animation);
    if (scene) {
        return spot === 'random' ? scene.randomSpot() : scene.spots()[spot] || null;
    }
    return null;
};
/**
 * @param {String} animation 
 * @param {String} target 
 * @param {Boolean} touchEffect
 * @returns {KunPlayList}
 */
KunPlayList.capture = function (animation = '', target = '', touchEffect = false) {
    const scene = this.get(animation);
    if (scene) {
        scene.capture(target, touchEffect);
    }
    return this;
};
/**
 * @param {String} name 
 * @returns {Object {X,Y}}
 */
KunPlayList.offset = function (name = '') {
    return this.has(name) ? this.get(name).offset() : { 'x': 0, 'y': 0 };
};



/**
 * 
 */
function KunAnimations_RegisterManagers() {

    var _kunAnimations_Initialize_Sprite = Sprite_Picture.prototype.initialize;
    Sprite_Picture.prototype.initialize = function (pictureId) {
        _kunAnimations_Initialize_Sprite.call(this, pictureId);
        this._touching = false;
        this._canceled = false;
        this._scroll = 0;
        this._animation = null;
    };

    var _kunAnimations_Load_Bitmap = Sprite_Picture.prototype.loadBitmap;
    Sprite_Picture.prototype.loadBitmap = function () {
        //vanilla image preload
        _kunAnimations_Load_Bitmap.call(this);
        //setup animation if its a scene spritesheet
        this._animation = KunPlayList.setup(this._pictureName, this._pictureId);
        if (this.isAnimated()) {
            this.animation().play(); //initialize and play
            this.bitmap.addLoadListener(this.updateAnimation.bind(this));
        }
    };

    var _kunAnimations_Update_Sprite = Sprite_Picture.prototype.update;
    Sprite_Picture.prototype.update = function () {
        //call vanilla
        _kunAnimations_Update_Sprite.call(this);

        if (this.isAnimated()) {
            //update the scene manager
            this.updateAnimation().processTouch();
            //this.processWheel();
        }
    };
    /**
     * @returns {Sprite_Picture}
     */
    Sprite_Picture.prototype.updateAnimation = function(){
        return this.updateAnimationFrame(this.animation());
    };
    /**
     * @param {KunAnimation} animation
     * @returns {Sprite_Picture}
     */
    Sprite_Picture.prototype.updateAnimationFrame = function ( animation = null ) {
        //const animation = this.animation();
        if (animation && animation.update()) {
            const frameIndex = animation.frame();
            const w = this.bitmap.width / animation.cols();
            const h = this.bitmap.height / animation.rows();
            const x = frameIndex % animation.cols() * w;
            const y = Math.floor(frameIndex / animation.cols()) * h;
            this.setFrame(x, y, w, h);
            //return true;                    
        }
        return this;
    };
    /**
     * @returns {KunAnimation}
     */
    Sprite_Picture.prototype.animation = function () {
        return this._animation || null;
    };
    /**
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.isAnimated = function () {
        return KunSceneManager.has(this._pictureName);
    }
    /**
     * @param {Number} x 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetX = function (x) {
        return this.picture().scaleX() > 0 ? Math.floor((x - this.picture().x()) * 100 / this.picture().scaleX()) : 0;
    };
    /**
     * @param {Number} y 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetY = function (y) {
        return this.picture().scaleY() > 0 ? Math.floor((y - this.picture().y()) * 100 / this.picture().scaleY()) : 0;
    };
    /**
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.validScale = function () {
        return this.picture() && this.picture().scaleX() && this.picture().scaleY() > 0;
    }
    /**
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.touch = function () {
        if (KunSceneManager.canTouch() && this.validScale()) {
            var x = TouchInput._x;
            var y = TouchInput._y;
            const spot = this.animation().touch(this.offsetX(x), this.offsetY(y));
            //console.log(spot);

            if (spot) {
                this.animation().target(spot, x, y);
                //, X, Y, this._pictureId);    
            }
            return true;
        }
        return false;
    };
    /**
     * @param {Boolean}
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.capture = function (to = false) {
        if (KunSceneManager.canCapture()) {
            if (to) {
                this.animation().captureTo(this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));
            }
            else {
                this.animation().captureFrom(this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));
            }
            return true;
        }
        return false;
    };
    /**
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.processTouch = function () {
        if (this.isAnimated() && KunSceneManager.canTouch()) {
            if (TouchInput.isCancelled()) {
                if (!this._canceled) {
                    this._canceled = true;
                    this._touching = false;
                    //drop spots here
                    //KunSceneManager.dropSpot();
                    //New Version
                    KunTouch.drop();
                    return this._touching;
                }
            }
            if (this._canceled) {
                this._canceled = false;
            }
            if (TouchInput.isTriggered()) {
                if (!this._touching) {
                    this._touching = true;
                }
            }
            if (TouchInput.isReleased()) {
                if (this._canceled) {
                    this._canceled = false;
                }
                if (this._touching) {
                    this._touching = false;
                    this.touch();
                }
            }
        }
        return this._touching;
    };
    /**
     * @returns {Boolean}
     */
    Sprite_Picture.prototype.canWheel = function(){
        return KunSceneManager.canWheel() && ++this._scroll % 2 === 0;
    };
    /**
     * @returns {Sprite_Picture}
     */
    Sprite_Picture.prototype.processWheel = function(){
        if( this.canWheel()){
            KunSceneManager.scroll( TouchInput.wheelY );
        }
        return this;
    };

    //OVERRIDE Game_Picture move method to capture the picture offset when required
    var _kunAnimations_Game_Picture_Move = Game_Picture.prototype.move;
    Game_Picture.prototype.move = function (origin, x, y, scaleX, scaleY, opacity, blendMode, duration) {

        //capture X and Y offset from picture name
        if (this.name()) {
            //import offset from currently active picture's frameset controller plus the scale
            var offset = KunPlayList.offset(this.name());
            //then apply the transformations
            x -= Math.floor(offset.x * (scaleX / 100));
            y -= Math.floor(offset.y * (scaleY / 100));
        }

        _kunAnimations_Game_Picture_Move.call(this, origin, x, y, scaleX, scaleY, opacity, blendMode, duration);
    };
    /**
     * 
     * @param {String} picture 
     * @param {Number} x 
     * @param {Number} y 
     */
    Game_Screen.prototype.exportPosition = function (picture, x, y) {
        var screenPic = this._pictures.filter(gp => gp !== null && gp._name === picture);
        //console.log(screenPic);
        if (screenPic.length > 0) {
            //KunSceneManager.DebugLog(`${x} , ${y}`);
            var px = screenPic[0]._x + Math.floor(screenPic[0]._scaleX / 100 * x);
            var py = screenPic[0]._y + Math.floor(screenPic[0]._scaleY / 100 * y);
            KunSceneManager.DebugLog(`${picture}: ${px},${py} (${screenPic[0]._x},${screenPic[0]._y})`);
            KunSceneManager.position(px, py);
        }
    };
 }
/**
 * 
 */
function KunAnimations_SetupCommands() {
    var _KunAnimations_SetupCommands = Game_Interpreter.prototype.pluginCommand;
    Game_Interpreter.prototype.pluginCommand = function (command, args) {
        _KunAnimations_SetupCommands.call(this, command, args);
        if (KunSceneManager.commands().includes(command) && args.length) {
            var _import = args.includes('import');
            switch (args[0]) {
                case 'speed':
                case 'variant':
                    if (args.length > 2) {
                        var values = args[2].split(':').map(value => parseInt(value));
                        if( args.includes('import')){
                            values = values.map( value => $gameVariables.value(value));
                        }
                        args[1].split(':')
                            .map(name => KunPlayList.get(name))
                            .forEach(anim => anim && anim.setVariant(values[Math.floor(Math.random() * values.length)]));
                    }
                    break;
                case 'stagemenu':
                    if (args.length > 1) {
                        var animations = args[1].split(':');
                        var animation = animations[Math.floor(Math.random() * animations.length)];
                        this.animationMenuSelector(
                            KunPlayList.get(animation),'stage',
                            args[2] || 'skip',
                            args[3] || 'right',
                            args[4] || 'window',
                        );
                    }
                    break;
                case 'spotmenu':
                    if (args.length > 1) {
                        var animations = args[1].split(':');
                        var animation = animations[Math.floor(Math.random() * animations.length)];
                        this.animationMenuSelector(
                            KunPlayList.get(animation),
                            args.includes('touch') && 'touch' || 'target',
                            args[2] || 'skip',
                            args[3] || 'right',
                            args[4] || 'window',
                        );
                    }
                    break;
                case 'animationmenu':
                    if (args.length > 1) {
                        var animations = args[1].split(':');
                        var animation = animations[Math.floor(Math.random() * animations.length)];
                        this.animationMenuSelector(
                            KunPlayList.get(animation),'animation',
                            args[2] || 'skip',
                            args[3] || 'right',
                            args[4] || 'window',
                        );
                    }
                    break;
                case 'actions':
                    if (args.length > 1) {
                        var animation = KunPlayList.get(args[1]);
                        if (animation) {
                            animation.runActions(args.length > 2 && args[2] || '');
                        }
                    }
                    break;
                case 'create':
                    var pictures = args[1].split(':');
                    var setup = args[2].split(':').map(n => parseInt(n));
                    var alias = args[3] || '';
                    var animation = args[4] && args[4].split(':') || [];
                    var picture = pictures[pictures.length > 1 ? Math.floor(Math.random() * pictures.length) : 0];
                    KunPlayList.setup(
                        picture, setup[0], alias,
                        animation.length ? animation[Math.floor(Math.random() * animation.length)] : '');
                    KunSceneManager.preparePicture(
                        //ID and picture
                        picture,
                        setup[0],       //Picture ID
                        setup[1] || 0,   //posx
                        setup[2] || 0,   //posy
                        setup[3] || 100, //scalex
                        setup[4] || 100, //scaley
                        setup.length > 5 ? setup[5] : 0, //opacity
                        setup[6] || 0, //blend
                        setup[7] || 0, //origin
                    );
                    break;
                case 'replace':
                    var pictures = args[1].split(':');
                    var animation = args[4] && args[4].split(':') || [];
                    KunPlayList.setup(
                        pictures[pictures.length > 1 ? Math.floor(Math.random() * pictures.length) : 0],
                        args[2] && parseInt(args[2]) || 0,
                        args[3] || '',
                        animation.length ? animation[Math.floor(Math.random() * animation.length)] : '');
                    break;
                case 'playlist':
                    if (args.length > 2) {
                        var animations = args[2].split(':');
                        args[1].split(':').forEach(function (scene) {
                            if (animations.includes('clear')) {
                                KunPlayList.clear(scene);
                            }
                            else {
                                KunPlayList.push(scene, animations);
                            }
                        });
                    }
                    else if (args.includes('clear')) {
                        KunPlayList.clear();
                    }
                    break;
                case 'spot':
                    if (args.length > 1) {
                        var animations = args[1].split(':');
                        var animation = animations[Math.floor(Math.random() * animations.length)];
                        var spots = args.length > 2 && args[2].split(':') || ['random'];
                        KunPlayList.capture(
                            animation,
                            spots[Math.floor(Math.random() * spots.length)],
                            args.length > 3 && args[3] === 'touch');
                    }
                    break;
                case 'queue':
                    if (args.length > 1) {
                        var spots = args.length > 2 && args[2].split(':') || ['random'];
                        var touch = args.length > 3 && args[3] === 'touch';
                        spots.forEach( animation => {
                            KunPlayList.capture(args[1],animation,touch);
                        });
                    }
                    break;
                case 'target':
                    KunTouch.target(args.includes('random'));
                    break;
                case 'alias':
                    if (args.length > 2) {
                        KunPlayList.setup(args[2],0,args[1]);
                        //KunPlayList.setAlias(args[1], args[2]);
                    }
                    break;
                case 'stage':
                    if( args.length > 2 ){
                        var stages = args[2].split(':');
                        KunPlayList.setstage( args[1], stages[Math.floor(Math.random() * stages.length)]);
                    }
                    break;
                case 'stages':
                    if( args.length > 2 ){
                        var animation = KunPlayList.get( args[1] );
                        if( animation ){
                            args.slice(2).map( stage => stage.split(':')).filter( stage => stage.length > 1 ).forEach( stage => {
                                animation.addStage(stage[0],stage[1]);
                            });
                        }
                    }
                    break;
                case 'prepare':
                case 'complete':
                    //clear all referenecs before starting scene
                    KunPlayList.reset();
                    break;
                case 'clear':
                    if (args.length > 1) {
                        switch (args[1]) {
                            case 'playlist':
                                KunPlayList.clear();
                                break;
                            case 'targets':
                                KunTouch.clear();
                                break;
                            case 'scenes':
                                KunPlayList.reset();
                                break;
                            case 'all':
                                KunPlayList.clear().reset();
                                KunTouch.clear();
                                break;
                        }
                    }
                    else {
                        KunTouch.clear();
                    }
                    break;
                case 'fps':
                    if (args.length > 2) {
                        var fps = parseInt(args[2]);
                        if (_import) {
                            fps = $gameVariables.value(fps);
                        }
                        var animation = KunPlayList.get(args[1]);
                        if (animation) {
                            animation.setFps(fps);
                        }
                    }
                    break;
                case 'reset':
                    if (args.length > 1) {
                        //KunSceneManager.reset(KunSceneManager.getAlias(args[1]), args.length > 2 && args[2] === 'replay');
                    }
                    break;
                case 'play':
                case 'set':
                    if (args.length > 2) {
                        var animations = args[2].replace(/\./g, ':').split(':').map( name => KunPlayList.alias(name));
                        var spots = (args.length > 3 && args[3] === 'spot' && args.length > 4 && args[4].split(':')) || [];
                        args[1].split(':').map( name => KunPlayList.get(name)).filter( anim => anim !== null ).forEach( animation => {
                            //play random selection for any animated picture :D
                            animation.play(animations[Math.floor(Math.random() * animations.length)]);
                            if (spots.length) {
                                KunPlayList.capture(animation.name(), spots[Math.floor(Math.random() * spots.length)]);
                            }
                        });
                        if (args.length > 3 && args[3] === 'wait') {
                            if (args.length > 4) {
                                var wait = args[4].split(':').map(count => parseInt(count));
                                this.wait(wait.length > 1 ? wait[0] + Math.floor(Math.random() * (wait[1] - wait[0])) : wait[0]);
                            }
                        }
                    }
                    break;
                case 'pause':
                    if (args.length > 1) {
                        args[1].split(':')
                            .filter(animation => KunPlayList.has(animation, true))
                            .map(animation => KunPlayList.get(animation))
                            .forEach(animation => animation.stop());
                    }
                    break;
                case 'resume':
                    if (args.length > 1) {
                        args[1].split(':')
                            .filter(scene => KunPlayList.has(scene, true))
                            .map(scene => KunPlayList.get(scene))
                            .forEach(scene => scene.play());
                    }
                    break;
                case 'wait':
                    if (args.length > 1) {
                        var wait = args[1].split(':').map(t => parseInt(t));
                        if (_import && wait > 0) {
                            wait[0] = $gameVariables.value(wait[0]);
                            if (wait.length > 1) {
                                wait[1] = $gameVariables.value(wait[1]);
                            }
                        }
                        this.wait(wait.length > 1 ? wait[0] + Math.floor(Math.random() * wait[1]) : wait[0]);
                        KunSceneManager.DebugLog(`Waiting ${wait[0]} +(${wait.length > 1 ? wait[1] : 0}) fps ...`);
                    }
                    break;
                case 'mode':
                    KunSceneManager.setMode(args.length > 1 ? args[1] : KunSceneManager.Mode().Disabled);
                    if (KunSceneManager.canCapture()) {
                        KunSceneManager.DebugLog(`Capture Mode ON. Click and drag over a picture spot, then release to define the target area.`);
                    }
                    else {
                        KunSceneManager.DebugLog(`${KunSceneManager.mode()} mode on`);
                    }
                    break;
            }
        }
    };


    /**
     * @param {KunAnimation} animation Defined Label Menu to load options from
     * @param {Number} cancelType [random|first|last|skip|disable]
     * @param {Number} positionType [left|middle|right]
     * @param {Number} background [window|dim|none]
     */
    Game_Interpreter.prototype.animationMenuSelector = function (animation, action = 'touch', cancelType = 'skip', positionType = 'right', backgroundType = 'window') {
        if (animation instanceof KunAnimation) {
            var labels = animation.mapMenu(action);
            var options = Object.values(labels).map(option => option.split('|'))
                .map(items => items[Math.floor(Math.random() * items.length)]);
            var values = Object.keys(labels);
            var positions = ['left', 'middle', 'right'];
            var backgrounds = ['window', 'dim', 'transparent'];

            //setupCustomMenuSelector
            var position = positions.includes(positionType) ? positions.indexOf(positionType) : 2;
            var background = backgrounds.includes(backgroundType) ? backgrounds.indexOf(backgroundType) : 2;
            switch (cancelType || '') {
                case 'random':
                    cancel = Math.floor(Math.random() * values.length);
                case 'last':
                    cancel = values.length - 1;
                case 'skip':
                    cancel = -2;
                case 'disable':
                    cancel = -1;
                case 'first':
                default:
                    cancel = 0;
            }

            $gameMessage.setChoices(options, 0, cancel);
            $gameMessage.setChoiceBackground(background);
            $gameMessage.setChoicePositionType(position);
            $gameMessage.setChoiceCallback(function (n) {
                if (action === 'touch' || action === 'capture') {
                    animation.capture(values[n], action === 'touch');
                }
                else if (action === 'animation') {
                    animation.play(values[n]);
                }
                else if( action === 'stage' ){
                    KunPlayList.setstage( animation.name(true), values[n] );
                }
            }.bind(this));

            this.setWaitMode('message');
        }
    };
}

/********************************************************************************************************************
 * 
 * INITIALIZER
 * 
 *******************************************************************************************************************/

(function ( /* args */) {

    KunSceneManager.Initialize();

    KunAnimations_RegisterManagers();

    KunAnimations_SetupCommands();
})( /* initializer */);



