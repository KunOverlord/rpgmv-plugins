//=============================================================================
// KunAnimations.js
//=============================================================================
/*:
 * @filename KunAnimations.js
 * @plugindesc Kun Interactive Picture Animations (Amirian Release) - Animate pictures with custom framesets and commands, now featuring an interactive framework to click over specific hotspots depending on the frameset running.
 * @version 1.99.2b
 * @author KUN
 * @target MC | MZ
 * 
 * @help
 * 
 * COMMANDS:
 * 
 *      KunAnimations set animation-name [setName] [wait frames:frame_offset]
 *          Switch animation frameset setName for animation-name
 *          If offsetVarx and offsetVarY are defined, both vars will apply the defined offset
 *          Use offsetScale % to scale the offset displacement for each coordinate
 * 
 *      KunAnimations reset animation-name [replay]
 *          Resets the given animation
 *          Restarts the controller if replay is required
 * 
 *      KunAnimations fps animation-name [fps] [import]
 *          Set custom frames per second for the playing animation-name. Define import to use a Game Variable to grab the fps from
 * 
 *      KunAnimations pause animation-name
 *          Pause animation-name if playing
 * 
 *      KunAnimations resume animation-name
 *          Resume animation-name if paused
 * 
 *      KunAnimations target [random]
 *          Update to the next target in the list of touched spots
 * 
 *      KunAnimations spot animation-name spot-name
 *          Export the X and Y coordinates of the spot-name area if available in the current animation play
 * 
 *      KunAnimations mode [capture|touch|disabled]
 *          Set the mouse interactive mode. Set touch to activate the interactive events. Set capture to describe hotspot areas in the console (requires debug mode on). Set disable to turn off the event listener.
 * 
 *      KunAnimations clear [targets | alias]
 *          Clear the current target queue
 *          Clear targets or defined aliases
 * 
 *      KunAnimations alias [alias_name] [animation_name]
 *          Create an alias for a specific animation controller to ease picture swapping with the same tags
 * 
 *      KunAnimations play [sound_bank_name] [wait_seconds] [random_elapsed_seconds]
 *          Play a sound bank selection by name
 *          Set wait seconds to include a time waiting pause before running the next events
 *          Add random elapsed seconds to define a randomized timespan
 * 
 *      KunAnimations interruption [on|off]
 *          Allow a sound bank selection to interrupt other Sound Effects playing by MEdia Player
 *          Activated by default for those sound banks marked with Allow SE interruption
 * 
 *      KunAnimations wait [elapsed_seconds] [random_elapsed_seconds]
 *          Wait for elapsed seconds before running the next routines in the event editor
 *          Add random elapsed seconds to define a randomized timespan
 * 
 *      KunAnimations prepare | complete
 *          Resets all the active animations to prepare a new animation or close a running one.
 * 
 * 
 * HIERARCHY:
 * 
 *  -> Scene
 *  ----> AnimationLayer
 *  --------> TouchSpot
 * 
 *  - Animation Controllers
 *    defined by the Selected Picture File.
 *    Here you can setup the columns and rows, to properly display the frames.
 * 
 *  - Animation Frameset Groups
 *    A list of frames to play, with a custom FPS, behavior and looping iterations.
 * 
 *  - Touch Spots
 *    Every frameset animates a list of frames, but you can define on these a list of specific spots
 *    to click and cause a reaction, update a Game Variable, play a custom sound effect,
 *    and change to another specific frameset.
 * 
 * 
 * @param debug
 * @text Debug Level
 * @desc Show debug info. Activate Trace Log to detail the imports and exports of data.
 * @type select
 * @option TraceLog
 * @value 2
 * @option Enabled
 * @value 1
 * @option Disabled
 * @value 0
 * @default 0
 * 
 * @param defaultFPS
 * @text Master Frame Time
 * @desc default frame time
 * @type number
 * @min 1
 * @default 10
 * 
 * @param touchVarCounter
 * @text Touch Counter Variable
 * @desc This variable handles the counter of enqueued interactions performed by the player
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchVarLimit
 * @parent touchVar
 * @text Touch Limit Variable
 * @desc How many interactions can be saved in the queue. Can be updated in game to increase the touch events.
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchMode
 * @parent touchVar
 * @text Touch Mode Switch
 * @desc Use it to keep control of the interactive mode in the event editor. Use KunAnimations mode touch | disable to change it.
 * @type switch
 * @default 0
 * 
 * @param touchX
 * @text Touch X Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchY
 * @text Touch Y Var
 * @type variable
 * @min 0
 * @default 0
 * 
 * @param touchSfx
 * @text Default Touch SE
 * @desc Define a default sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param cancelSfx
 * @text Don't Touch SE
 * @desc Define a no touch sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param controllers
 * @type struct<Controller>[]
 * @text Animation Scenes
 * @desc Define the DataBase of Animation Scene Controllers (keep it clean and easy!!)
 * 
 * @param animationPacks
 * @type number
 * @text Animation Pack Expansions
 * @desc define how many plugin expansions to load
 * @min 0
 * @max 20
 * @default 0
 */
/*~struct~Controller:
 *
 * @param source
 * @text Source Picture Pack
 * @desc Add one or more source pictures with the same frameset columns and rows, to use with the same animation rules. Duplicated pictures will be discarded.
 * @type file[]
 * @require 1
 * @dir img/pictures/
 * 
 * @param cols
 * @text Columns
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param rows
 * @text Rows
 * @type number
 * @min 1
 * @max 32
 * @default 1
 * 
 * @param fps
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param framesets
 * @type struct<FrameSet>[]
 * @text Framesets
 * @desc Frameset Collection
 * @default []
 * 
 * @param hotspots
 * @type struct<HotSpot>[]
 * @text Event Hotspots
 * @desc Add the interactive spots here
 * @default []
 * 
 * @param soundBankPrefix
 * @type text[]
 * @text Sound Bank Prefix
 * @desc Add here the sound bank prefix for each picture souce when required
 * 
 */
/*~struct~FrameSet:
 * 
 * @param name
 * @text Name
 * @type text
 * @default new-layer
 * 
 * @param frames
 * @text Frames
 * @type number[]
 * @min 0
 * @desc List of frames to play in this animation
 * @default []
 * 
 * @param type
 * @text Animation Type
 * @type select
 * @option Forward (default)
 * @value forward
 * @option Reverse
 * @value reverse
 * @option Ping-Pong
 * @value ping-pong
 * @option Static
 * @value static
 * @default forward
 * 
 * @param fps
 * @text Frames Per Second
 * @desc Default FPS for this frameset (leave to 0 to get master FPS as default)
 * @type number
 * @min 0
 * @default 0
 * 
 * @param loops
 * @type number
 * @text Loops
 * @desc number of times the animation will play before switching to the next animation. Leave it to 0 for endless loops (no next animation)
 * @default 0
 * 
 * @param next
 * @text Next FrameSets
 * @type text[]
 * @desc Define the next frameset to call. If more than one specified, they will be randomly called
 * 
 * @param offsetX
 * @text X Offset
 * @type number
 * @default 0
 * 
 * @param offsetY
 * @text Y Offset
 * @type number
 * @default 0
 * 
 * @param clearTargets
 * @type boolean
 * @text Clear Targets
 * @desc Clear all targets in the queue when loading this frameset layer
 * @default false
 * 
 * @param spots
 * @type struct<TouchSpot>[]
 * @text Touch Spots
 * @desc Interactive Spots to fire events
 * @default []
 * 
 * @param bank
 * @text Sound Bank
 * @desc Type in a defined sound bank name to play a special sound set each time this frameset is started.
 * @type text[]
 * @default []
 * 
 */
/*~struct~TouchSpot:
 * 
 * @param name
 * @text Name
 * @type text
 * @default touch-me-here
 * 
 * @param trigger
 * @text On Click
 * @type select
 * @option Instant Run
 * @value instant
 * @option Queue
 * @value queue
 * @option Next Frame
 * @value frame
 * @option Ignore
 * @value ignore
 * @default queue
 * 
 * @param next
 * @text Switch Frameset
 * @desc Jump to Frameset on touched (allow mrandom options when more than 1)
 * @type text[]
 * @default []
 * 
 */
/*~struct~HotSpot:
 * 
 * @param name
 * @text Name
 * @type text
 * @default touch-me-here
 * 
 * @param x1
 * @text X1
 * @type number
 * @min 0
 * @desc X origin coordinate
 * 
 * @param y1
 * @text Y1
 * @type number
 * @min 0
 * @desc Y origin coordinate
 * 
 * @param x2
 * @text X2
 * @type number
 * @min 0
 * @desc X destination coordinate
 * 
 * @param y2
 * @text Y2
 * @type number
 * @min 0
 * @desc Y destination coordinate
 * 
 * @param sfx
 * @text Touch Audio SFX
 * @desc Define a specific sound effect
 * @type file
 * @require 1
 * @dir audio/se/
 * 
 * @param varId
 * @text Game Variable ID
 * @type variable
 * @min 0
 * @desc Game Variable Mutator. Leave to 0 to not update variables.
 * @default 0
 * 
 * @param behavior
 * @parent varId
 * @text Update Behavior
 * @desc How to modify the value on Game Variable ID
 * @type select
 * @option Add (default)
 * @value add
 * @option Substract
 * @value sub
 * @option Set
 * @value set
 * @option Set Frame
 * @value frame
 * @option Ignore
 * @value ignore
 * @default add
 * 
 * @param amount
 * @parent varId
 * @text Update Amount
 * @type number
 * @min 1
 * @default 1
 * 
 */

//const { count } = require('console');

/**
 * @description KUN Modules
 * @type KUN
 */
//var KUN = KUN || {};

/**
 * 
 * @returns 
 */
function KunSceneManager() {
    throw `${this.constructor.name} is a Static Class`;
}
/**
 * 
 * @returns KunSceneManager
 */
KunSceneManager.Initialize = function(){

    var parameters = this.PluginParameters()

    this._debug = parseInt( parameters.debug || KunSceneManager.DebugMode().Disabled );
    this._fps = parseInt(parameters.defaultFPS );
    this._touchVar = parseInt(parameters.touchVarCounter || 0 );
    this._limitVar = parseInt(parameters.touchVarLimit || 0 );
    this._touchMode = parseInt(parameters.touchMode || 0 );
    //added as new version to implement external plugin animation packs avoiding overloading the KunAnimationPacks plugin
    this._animationPacks = parseInt(parameters.animationPacks || 0);

    this._varX = parseInt(parameters.touchX || 0 );
    this._varY = parseInt(parameters.touchY || 0 );
    this._sfx = {
        'touch': parameters.touchSfx || '',
        'cancel': parameters.cancelSfx || '',
    };


    this._mode = KunSceneManager.Mode().Disabled;
    this._soundBanks = {};
    this._scenes = {};

    this._alias = {};
    this._targets = [];

    this._breakInterrupt = false;

    //return this.setupScenes( KunSceneImporter.importAnimationPacks( parameters.controllers.length > 0 ? JSON.parse(parameters.controllers ) : [] ) );
    return this.setupScenes( KunSceneImporter.importExpansionPacks( parameters.controllers.length > 0 ? JSON.parse(parameters.controllers ) : [] ) );
};
/**
 * @returns Object
 */
KunSceneManager.DebugMode = function(){
    return {
        'Disabled':0,
        'Enabled': 1,
        'TraceLog': 2,
    };
};
/**
 * @returns Number
 */
KunSceneManager.animationPacks = function(){
    return this._animationPacks;
}
/**
 * 
 * @param {Number} total
 * @param {Number} frames
 */
KunSceneManager.GenerateFramesets = function( total, frames ){
    var output = [];
    if( typeof total === 'number' && typeof frames === 'number' && total >= frames ){
        var sets = Math.floor(total / frames);
        for(var i = 0 ; i < sets ; i++ ){
            var fs = [];
            for(var j = 0 ; j < frames ; j++ ){
                fs.push( i * frames + j );
            }
            output.push( fs.slice() );
        }
    }
    return output.forEach( function( fs ){
        console.log(fs.map( fr => fr.toString() ));
    });
};
/**
 * 
 * @param {Boolean} stop 
 */
KunSceneManager.stopInterruption = function( stop ){
    this._breakInterrupt = typeof stop === 'boolean' && stop;
    return this.canInterrupt();
};
/**
 * @returns Boolean
 */
KunSceneManager.canInterrupt = function(){
    return !this._breakInterrupt;
};
    /**
     * @returns Boolean
     */
    KunSceneManager.debug = function( level ){
        if( typeof level === 'number' && level > 0 ){
            return this._debug >= level;
        }
        return this._debug > KunSceneManager.DebugMode().Disabled;
    };
    /**
     * @param {Boolean} list 
     * @returns Object | Object[]
     */
    /*KunSceneManager.banks = function( list ){
        return typeof list === 'boolean' && list ? Object.values( this._soundBanks ) : this._soundBanks;
    };*/
    /**
     * @param {String} bank 
     * @returns Boolean
     */
    /*KunSceneManager.hasBank = function( bank ){
        return typeof bank === 'string' && bank.length > 0 && this._soundBanks.hasOwnProperty( bank );
    };*/
    /**
     * @param {KunSoundBank} bank 
     * @returns KunSceneManager
     */
    /*KunSceneManager.addBank = function( bank){
        if( bank instanceof KunSoundBank && !this.hasBank( bank ) ){
            this._soundBanks[ bank.name() ] = bank;
        }
        return this;
    };*/
    /**
     * @param {String} bank 
     * @param {Number} round
     * @returns KunSceneManager
     */
    KunSceneManager.playBank = function( bank , round ){
        if( typeof KunSoundBanks === 'function' ){
            //KunSceneManager.DebugLog( `Playing Sound Bank: ${bank}` );
            KunSoundBanks.play( bank , round );
        }
        /*if( this.hasBank( bank ) ){
            //console.log( bank );
            this.banks()[bank].play();
        }*/
        return this;
    };
    /**
     * @param {String} bank 
     * @returns KunSoundBank
     */
    KunSceneManager.soundBank = function( bank ){
        if( typeof KunSoundBanks === 'function' ){
            return KunSoundBanks.get( bank );
        }
        return null;
        //return this.hasBank( bank ) ? this.banks()[bank] : KunSoundBank.Empty();
    };
    /**
     * 
     * @param {String} alias 
     * @param {String} original 
     * @returns KunSceneManager
     */
    KunSceneManager.setAlias = function( alias , original ){
        this._alias[alias] = original;
        return this;
    };
    /**
     * @param {String} alias 
     * @returns String
     */
    KunSceneManager.getAlias = function( alias ){
        return this._alias.hasOwnProperty(alias) ? this._alias[alias] : alias;
    }
    /**
     * 
     * @returns KunSceneManager
     */
    KunSceneManager.clearAlias = function(){
        this._alias = {};
        return this;
    };
    /**
     * @param {String} mode 
     * @returns KunSceneManager
     */
    KunSceneManager.setMode = function( mode ){
        this._mode = mode;
        switch( this._mode ){
            case KunSceneManager.Mode().Capture:
            case KunSceneManager.Mode().Touch:
                this.unlock(true);
                break;
            case KunSceneManager.Mode().Disabled:
            default:
                this.clearTargets().lock();
                break;
        }
        return this;
    };
    /**
     * @returns Object
     */
    KunSceneManager.dump = function(){
        return this;
    }
    /**
     * @returns String
     */
    KunSceneManager.sfx = function( name ){
        return typeof name === 'string' && name.length && this._sfx.hasOwnProperty(name) ? this._sfx[name] : this._sfx.touch;
    };
    /**
     * @returns Number
     */
    KunSceneManager.limit = function(){
        return this._limitVar > 0 ? $gameVariables.value( this._limitVar ) : 1;
    };
    /**
     * @param {Boolean} unlock
     * @returns KunSceneManager
     */
    KunSceneManager.unlock = function( unlock ){
        if( this._touchMode ){
            $gameSwitches.setValue( this._touchMode, typeof unlock === 'boolean' && unlock );
        }
        return this;
    };
    /**
     * @returns KunSceneManager
     */
    KunSceneManager.lock = function( ){
        return this.unlock(false);
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.locked = function(){
        return this._mode === KunSceneManager.Mode().Disabled;
        return this._touchMode > 0 && !$gameSwitches.value(this._touchMode);
    };
    /**
     * @param {String} name 
     * @returns Object {X,Y}
     */
    KunSceneManager.offset = function( name ){
        var picture = this.get(name);
        if( picture !== null ){
            var layer = picture.current();
            if( layer !== null ){
                return {
                    'x':layer.offsetX(),
                    'y':layer.offsetY()
                };
            }
        }
        return {'x':0,'y':0};
    };
    /**
     * @param {String} controller
     * @param {String} spot
     * @param {Number} x 
     * @param {Number} y 
     * @returns Boolean
     */
    KunSceneManager.enqueue = function( controller , spot , x , y  ){
        if( this.targets().length < this.limit() ){
            this.targets().push({
                'controller':controller,
                'spot': spot,
                'x':x,
                'y':y,
                //'sx': typeof sx === 'number' && sx > 0 ? sx : x,
                //'sy': typeof sy === 'number' && sy > 0 ? sy : y,
            });
            //KunSceneManager.DebugLog(`Enqueuing spot ${spot} (${x},${y})`);
            this.updateTouchPoints( this.countTargets()).playFx();
            return true;
        }
        else{
            KunSceneManager.PlayFX(this.sfx('cancel'));
        }
        return false;
    };
    /**
     * @returns Array
     */
    KunSceneManager.targets = function(){
        return this._targets;
    };
    /**
     * @returns Number
     */
    KunSceneManager.countTargets = function(){
        return this._targets.length;
    }
    /**
     * 
     * @returns KunSceneManager
     */
    KunSceneManager.clearTargets = function(){
        this._targets = [];
        return this.updateTouchPoints();
    };
    /**
     * Stops all active scenes and resets their counters
     * @returns KunSceneManager
     */
    KunSceneManager.clearPlaying = function(){
        this.scenes(true).filter( scene => scene.playing() ).forEach( scene => scene.stop( true ) );
        return this;
    };
    /**
     * @param {Boolean} random 
     * @returns Object
     */
    KunSceneManager.nextSpot = function( random ){
        var spot = typeof random === 'boolean' && random && this.countTargets() > 1 ?
            this.targets().splice( Math.floor(Math.random() * this.countTargets( ) ), 1) :
            this.targets().shift();
        return Array.isArray(spot) ? spot[0] : spot;
    };
    /**
     * Export X,Y coordinates of the given spot
     * @param {String} picture 
     * @param {String} target 
     * @returns KunSceneManager
     */
    KunSceneManager.captureSpot = function( picture , target ){
        var scene = this.get(picture);
        if(scene !== null && scene.playing() ){
            var spot = scene.current().getSpot( target );
            if( spot !== null ){
                this.DebugLog(`Targeting Spot ${picture}.${target} ...`);
                $gameScreen.exportPosition( picture , spot.getPosX(true),spot.getPosY(true));
            }
            else{
                this.DebugLog(`Spot ${picture}.${target} not found on the curent animation layer`);
            }
        }
        return this;
    };
    /**
     * @param {Number} x 
     * @param {Number} y 
     * @returns 
     */
    KunSceneManager.capturePictureSprite = function( picture ){

        
    };
    /**
     * @param {Boolean} random
     * @returns KunSceneManager
     */
    KunSceneManager.target = function( random ){
        if(this.countTargets()){
            var spot = this.nextSpot( random );
            //console.log(spot);
            var controller = this.get(spot.controller);
            if( controller !== null ){
                var fs = controller.current();
                if( fs !== null ){
                        var target = fs.getSpot(spot.spot);
                        if( target !== null ){
                            target.update();
                            //export X and Y positions
                            this.exportPosition( spot.x , spot.y );
                            //jump to next frameset (if any)
                            controller.changeLayer( target.next() , true );
                        }
                }
                else{
                    KunSceneManager.DebugLog(`Invalid FrameSet ${spot.spot}`);    
                }
            }
            else{
                //console.log(this.targets());
                KunSceneManager.DebugLog(`Invalid Controller ${spot.controller}`);
            }
        }    
        return this.updateTouchPoints(this.countTargets());
    };
    /**
     * @param {Number} x 
     * @param {Number} y 
     * @returns KunSceneManager
     */
    KunSceneManager.exportPosition = function( x  , y ){
        if( this._varX > 0 ){
            $gameVariables.setValue(this._varX,x);
        }
        if( this._varY > 0 ){
            $gameVariables.setValue(this._varY,y);
        }
        //KunSceneManager.DebugLog(`Event Clicked on ${x},${y}`);
        return this;
    };
    /**
     * @param {Number} counter 
     * @returns KunSceneManager
     */
    KunSceneManager.updateTouchPoints = function( counter ){
        if( this._touchVar > 0 ){
            $gameVariables.setValue(this._touchVar , counter  || 0 );
        }
        return this;
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.canCapture = function(){
        return this._mode === KunSceneManager.Mode().Capture;
    };
    /**
     * @returns Boolean
     */
    KunSceneManager.canTouch = function(){
        return this._mode === KunSceneManager.Mode().Touch && !this.locked();
    };
    /**
     * @returns String
     */
    KunSceneManager.mode = function(){
        return this._mode;
    };
    /**
     * @returns Number
     */
    KunSceneManager.defaultFps = function(){
        return this._fps;
    };
    /**
     * @returns Array | Object
     */
    KunSceneManager.scenes = function( list ){
        return typeof list === 'boolean' && list ? Object.values(this._scenes) : this._scenes;
    };
    /**
     * @returns Array
     */
    KunSceneManager.list = function( ){
        return Object.keys( this._scenes );
    };
    /**
     * @param {KunAnimationScene} controller 
     * @returns KunSceneManager
     */
    KunSceneManager.addScene = function( controller ){
        if( controller instanceof KunAnimationScene && !this.has(controller.name()) ){
            this._scenes[controller.name()] = controller;
        }
        return this;
    };
    /**
     * @param {String} name 
     * @returns Boolean
     */
    KunSceneManager.has = function( name ){
        return typeof name === 'string' && name.length && this._scenes.hasOwnProperty( name );
    }
    /**
     * @param {String} name 
     * @returns Boolean
     */
    KunSceneManager.isPlaying = function( name ){
        return this.has( name ) && this.get( name ).playing();
    };
    /**
     * @returns Array
     */
    KunSceneManager.controllers = function( list ){
        return typeof list === 'boolean' && list ? Object.values( this._scenes ) : this._scenes;
    };
    /**
     * @param {String} pictureName 
     * @returns {KunAnimationScene}
     */
    KunSceneManager.get = function( pictureName ){
        return this.has( pictureName ) ? this._scenes[pictureName] : null;
    }
    /**
     * @param {String} pictureName 
     * @returns {KunAnimationScene}
     */
    KunSceneManager.scene = function( pictureName ){
        return this.has( pictureName ) ? this._scenes[pictureName] : KunAnimationScene.INVALID;
    }
    /**
     * @param {String} pictureName 
     * @param {Boolean} reset
     * @returns {KunSceneManager}
     */
    KunSceneManager.stop = function( pictureName , reset ){
        reset = typeof reset === 'boolean' && reset;
        if( typeof pictureName === 'string' && pictureName.length ){
            var scene = this.get(pictureName);
            if( scene !== null ){
                scene.stop();
                if( reset ){
                    scene.reset();
                }
            }
        }
        else{
            this.scenes(true).filter( scene => scene.playing() ).forEach( function( scene){
                scene.stop();

            } );
        }
        
        return this;
    };
    /**
     * @param {String} picturename 
     * @param {Boolean} replay
     * @returns KunSceneManager
     */
    KunSceneManager.reset = function( picturename , replay  ){
        if( this.has( picturename)){
            this.get(picturename).first().reset( typeof replay === 'boolean' && replay );
        }
        return this;
    }
    /**
     * @param {String} pictureName 
     * @returns {KunSceneManager}
     */
    KunSceneManager.resume = function( pictureName ){
        if( typeof pictureName === 'string' && pictureName.length ){
            var scene = this.get( pictureName );
            if( scene !== null ){
                scene.resume();
            }
        }
        return this;
    };

    /**
     * @param {String} pictureName 
     * @param {String} layerName 
     * @returns {KunSceneManager}
     */
    KunSceneManager.playScene = function( pictureName , layerName ){
        //use has instead of isPlaying, since the scene might be paused at this point.
        //if( this.isPlaying( pictureName)){
        if( this.has( pictureName) ){
            this._scenes[ pictureName ].changeLayer(layerName, true ) ;
            if( KunSceneManager.debug( KunSceneManager.DebugMode().TraceLog ) ){
                KunSceneManager.DebugLog(`Playing ${pictureName}.${layerName}`);
            }    
            this.updateTouchPoints(this.countTargets());
        }
        else if(KunSceneManager.debug( )){
            KunSceneManager.DebugLog(`${pictureName}.${layerName} is not playing in the current scene`);
        }
        return this;
    };
    /**
     * 
     * @param {String} pictureName 
     * @param {Number} fps 
     * @returns {KunSceneManager}
     */
    KunSceneManager.overrideFPS = function( pictureName , fps ){
        if( this.isPlaying( pictureName ) ){
            this._scenes[ pictureName ].setFps( fps );
        }
        return this;
    };
    /**
     * @param {String} sfx
     * @returns KunSceneManager
     */
    KunSceneManager.playFx = function( sfx ){
        KunSceneManager.PlayFX( typeof sfx === 'string' && sfx.length ? sfx : this.sfx() );
        return this;
    };

KunSceneManager.PluginParameters = function(){
    return PluginManager.parameters('KunAnimations');
};
/**
 * 
 */
function KunSceneImporter(){
    throw `${this.constructor.name} is a Static Class`;
};
/**
 * @returns Object[]
 */
KunSceneImporter.AnimationPackParams = function(){
    return Object.values(PluginManager.parameters('KunAnimationPack'))
        .filter( pack => pack.length )
        .map( pack => JSON.parse(pack))
        .filter(pack => Array.isArray(pack));
};
/**
 * @param {Number|String} pack 
 * @returns Object[]
 */
KunSceneImporter.loadAnimationPack = function( pack ){
    var packName = 'KunAnimations-' + pack;
    var content = PluginManager.parameters(packName);
    var scenes = content !== null && content.hasOwnProperty('scenes') ? JSON.parse(content.scenes) : [];
    var title = content !== null && content.hasOwnProperty('name') ? `${packName} (${content.name})` : packName;

    KunSceneManager.DebugLog( `Loading ${scenes.length} scenes from ${title} ...` );

    return scenes;
        //.filter( scene => scene.length )
        //.map( scene => JSON.parse(scene));
}
/**
 * @param {Object[]} scenes 
 * @returns Object[]
 */
KunSceneImporter.importExpansionPacks = function( scenes ){
    if( !Array.isArray(scenes)){
        scenes = [];
    }
    if( scenes.length ){
        KunSceneManager.DebugLog( `Loading ${scenes.length} base scenes...` );
    }

    for( var i = 0 ; i < KunSceneManager.animationPacks() ; i++ ){
        this.loadAnimationPack( i + 1 ).forEach( function(pack){
            scenes.push(pack);
        });
    }

    return scenes.filter(scene => scene.length > 0 ).map(scene => JSON.parse(scene));
};
/**
 * @returns Object[]
 */
KunSceneImporter.importAnimationPacks = function( scenes ){
    if( !Array.isArray(scenes)){
        scenes = [];
    }
    if( scenes.length ){
        KunSceneManager.DebugLog( `Loading ${scenes.length} scenes.` );
    }
    //if there's KunAnimationPack loaded and contains secenes, import them all here too
    var packCount = 0;
    var sceneCount = 0;
    this.AnimationPackParams()
        .forEach( function( pack ){
            packCount++;
            pack.filter(scene => scene.length > 0 ).forEach( function( scene ){
                scenes.push( scene );
                sceneCount++;
            });
    });
    if( packCount ){
        KunSceneManager.DebugLog( `Loading ${sceneCount} scenes from ${packCount} extension packs.` );
    }
    return scenes.filter( scene => scene.length > 0 ).map( scene => JSON.parse( scene ) );
};
/**
 * @param {String} content 
 * @param {Object} onDefault 
 * @returns Object
 */
KunSceneImporter.parse = function( content , onDefault ){
    return typeof content === 'string' && content.length ? JSON.parse( content ) : (onDefault || null);
};
/**
 * @param {String} content 
 * @returns Array
 */
KunSceneImporter.parseArray = function( content ){
    return typeof content === 'string' && content.length > 0 ?  (/^\[.*\]$/.test(content) ? JSON.parse(content) : [content])   : []
};
/**
 * @param {Object[]} input 
 * @returns KunSceneManager
 */
KunSceneManager.setupScenes = function( input ){

    var _spotCounter = 0;
    var _layerCounter = 0;
    var _pictureCounter = 0;
    if( !Array.isArray(input)){
        input = [];
    }

    input.forEach(function( ctl ){
            var _pictures = KunSceneImporter.parseArray(ctl.source);
            var prefix = KunSceneImporter.parseArray( ctl.soundBankPrefix );
            var _scenes = [];
            var _spots = {};

            //Match fix to the next update and backwards compatibility with a single string value
            for( var i = 0 ; i < _pictures.length ; i++ ){
                _scenes.push( new KunAnimationScene(
                    _pictures[i],
                    parseInt(ctl.cols),
                    parseInt(ctl.rows),
                    parseInt( ctl.fps || 0 ),
                    prefix.length > i ? prefix[i] : '' ) );
            }
            //import all scene defined hotspots
            KunSceneImporter.parse(ctl.hotspots , []).map( spot => JSON.parse(spot) ).forEach(function( spot ){
                if( !_spots.hasOwnProperty( spot.name ) ){
                    _spots[spot.name] = spot;
                }
            });
            //prepare the layer framesets
            var _layers = KunSceneImporter.parse( ctl.framesets , [] );
            _layers.map( fs => KunSceneImporter.parse( fs ) ).filter( fs => fs !== null ).forEach(function(fs){
                    _layerCounter++;
                    var _layer = new KunAnimationLayer(
                        fs.name ,
                        fs.type ,
                        parseInt(fs.fps) ,
                        parseInt( fs.loops),
                        fs.next.length > 0 ? JSON.parse(fs.next) : '' ,
                        KunSceneImporter.parseArray( fs.bank ),
                        fs.offsetX, fs.offsetY,
                        fs.clearTargets === 'true' );

                    KunSceneImporter.parse( fs.frames , [] ).map( frame => parseInt( frame ) ).forEach(function( frame ){
                        _layer.add( frame );
                    });
                    //leave this here for debugging.
                    if( KunSceneManager.debug(KunSceneManager.DebugMode().TraceLog) ){
                        KunSceneManager.DebugLog(`Reading ${ctl.source}.${fs.name}`);
                    }

                    var _events = KunSceneImporter.parse( fs.spots , []);
                    _spotCounter += _events.length;

                    _events.map( spot => KunSceneImporter.parse( spot ) ).filter( spot => spot !== null ).forEach(  function( spot ){
                        if( _spots.hasOwnProperty(spot.name)){
                            var event = new KunTouchEvent(
                                spot.name,
                                parseInt(_spots[spot.name].x1),
                                parseInt(_spots[spot.name].y1),
                                parseInt(_spots[spot.name].x2),
                                parseInt(_spots[spot.name].y2),
                                parseInt(_spots[spot.name].varId || 0),
                                parseInt(_spots[spot.name].amount || 1),
                                _spots[spot.name].behavior || KunTouchEvent.Behaviour.Increase,
                                spot.trigger || KunTouchEvent.Trigger.Queue,
                                _spots[spot.name].sfx,
                                //spot.next.length > 0 ? JSON.parse(s.next) : []  );
                                KunSceneImporter.parseArray( spot.next , [] )  );
                                _layer.registerSpot(event);    
                        }
                    });
                    //KunSceneManager.DebugLog( _layer.spots() );
                    if( _layer.count() > 0 ){
                        _scenes.forEach( function( scene ){
                            scene.add( _layer );
                        } );
                    }
            });

            _scenes.forEach( function( scene ){
                if( scene.countFrames() ){
                    KunSceneManager.addScene( scene );
                }
            });
    });
                    //leave this here for debugging.
    if( KunSceneManager.debug(KunSceneManager.DebugMode().TraceLog) ){
        KunSceneManager.DebugLog(`Imported a total of ${_pictureCounter} animated pictures, ${_layerCounter} animation layers and ${_spotCounter} hotspots`);
    }

    return this;
};
/**
 * @param {Object[]} input 
 * @returns KunSceneManager
 */
/*KunSceneManager.ImportSoundBanks = function( input ){
    (input).map( sb => sb.length > 0 ? JSON.parse( sb ) : null ).forEach( function( bank ){
        var sb = new KunSoundBank( bank.name , bank.chance , bank.interrupt === 'true' , parseInt( bank.round  ||  0 ) );
        (bank.pitch.length > 0 ? JSON.parse(bank.pitch) : []).map(pitch => parseInt( pitch )).forEach(function( pitch ){
            sb.addPitch( pitch );
        });
        (bank.pan.length > 0 ? JSON.parse(bank.pan) : []).map(pan => parseInt( pan )).forEach(function( pan ){
            sb.addPan( pan );
        });
        (bank.volume.length > 0 ? JSON.parse(bank.volume) : []).map(volume => parseInt( volume )).forEach(function( volume ){
            sb.addVol( volume );
        });
        (bank.sfx.length > 0 ? JSON.parse(bank.sfx) : []).forEach(function( se ){
            //if( KunSceneManager.SoundEffectExists(se)){
                sb.addSe( se );
            //}
        });
        KunSceneManager.addBank( sb );
    });
    return this;
};*/
/**
 * @returns Object
 */
KunSceneManager.Mode = function(){
    return {
        'Disabled': 'disabled',
        'Touch': 'touch',
        'Capture': 'capture',
    };
};
KunSceneManager.Behavior = {
    'Forward': 'forward',
    'Reverse': 'reverse',
    'PingPong': 'ping-pong',
    'Static': 'static',
};

KunSceneManager.Capture = [];
/**
 * @param {String} sfx 
 * @param {Number} pitch
 * @param {Number} pan
 */
KunSceneManager.PlayFX = function( sfx , pitch , pan ){
        if(  sfx.length ){
            if( typeof pitch !== 'number' ){
                pitch = 90 + Math.floor(Math.random() * 20);
            }
            if( typeof pan !== 'number' ){
                pan = Math.floor(Math.random() * 20) - 10;
            }
            this.AudioManager( sfx , 100 , pitch , pan );
            //AudioManager.playSe({name: sfx , pan: pan, pitch: pitch, volume: 100});
        }
};
/**
 * 
 * @param {String} se 
 * @param {Number} volume 
 * @param {Number} pitch 
 * @param {Number} pan 
 * @param {Boolean} interrupt
 */
KunSceneManager.AudioManager = function( se , volume , pitch , pan , interrupt ){
    if( se.length ){
        if( typeof interrupt === 'boolean' && interrupt ){
            AudioManager.stopSe();
        }
        //KunSceneManager.DebugLog( `Playing ${se} at vol ${volume}, pitch ${pitch} and pan ${pan} ${interrupt}` );
        AudioManager.playSe({name: se , pan: pan || 0, pitch: pitch || 100, volume: volume || 90 } );
    }
};
/**
 * @param {String} message 
 */
KunSceneManager.DebugLog = function( message ){
    if( KunSceneManager.debug() ){
        console.log( typeof message === 'object' ? message : `[ KunSceneManager ] ${message.toString()}` );
    }
};
/**
 * @param {String} name 
 * @returns Boolean
 */
KunSceneManager.SoundEffectExists = function( name ){
    return this.FileExists( this.FilePath( name + AudioManager.audioFileExt() ) );
}
/**
 * @param {String} path 
 * @returns Boolean
 */
KunSceneManager.FileExists = function( path ){

    var fs = require('fs');
    if( fs.existsSync( path )){
        return true;
    }

    if( KunSceneManager.debug( KunSceneManager.DebugMode().TraceLog ) ){
        KunSceneManager.DebugLog( `File missing ${path}` );
    }

    return false;
};
/**
 * @param {String} file 
 * @returns String
 */
KunSceneManager.FilePath = function( file ){
    var path = require('path');
    var base = path.dirname(process.mainModule.filename);
    return path.join(base, `audio/se/${file}`);
};


/**
 * 
 */
function KunAnimationScene(){
    this.initialize.apply( this , arguments );
}

KunAnimationScene.prototype.initialize = function( name , cols , rows , fps , prefix ){

    this._name = name;
    this._cols = cols || 1;
    this._rows = rows || 1;
    this._animationLayers = {
        //setup frameset collection here
    };
    this._elapsed = 0;
    this._loopCount = 0;
    this._backwards = false;
    this._playing = false;

    this._index = 0;
    this._current = '';

    //this one can be overriden
    this._fps = fps || KunSceneManager.defaultFps();
    this._touching = false;
    this._prefix = typeof prefix === 'string' && prefix.length ? prefix : '';
    //this._touch = [];
    //use this to capture coordinates in Dev Mode
    this._capture = [];
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.isValid = function(){ return this._name !== 'INVALID' && !this.empty(); };
/**
 * @returns String
 */
KunAnimationScene.prototype.toString = function(){ return this.name(); };
/**
 * @returns String
 */
KunAnimationScene.prototype.name = function(){ return this._name; };
/**
 * @returns KunAnimationLayer
 */
KunAnimationScene.prototype.current = function(){ return this.has(this._current) ? this._animationLayers[this._current] : null; };
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.canTouch = function(){
    var current = this.current();
    return current !== null ? current.isInteractive() : false;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent
 */
KunAnimationScene.prototype.getTouched = function( x , y ){

    var current = this.current();
    return current !== null ? current.touchSpot( x , y ) : null;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @param {Number} sx
 * @param {Number} sy
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.touch = function( x  , y , sx , sy){
    //KunSceneManager.DebugLog(`Clicked x${x}(${sx}), y${y}(${sy})`);
    var spot = this.getTouched(x , y);
    if( spot !== null ){
        switch( spot.trigger() ){
            case KunTouchEvent.Trigger.Queue:
                KunSceneManager.enqueue( this.name() , spot.name() , sx , sy );
                break;
            case KunTouchEvent.Trigger.Instant:
                //perform spot update
                spot.update().touchSfx();
                //export X and Y positions
                KunSceneManager.exportPosition( sx , sy );
                //jump to next frameset (if any)
                this.changeLayer( spot.next(), true );
                break;
            case KunTouchEvent.Trigger.Frame:
                this.changeLayer(spot.next());
                spot.setValue(this.current().first()).touchSfx();
                break;
        }
        
    }
    return this;
};
/**
 * @returns Array
 */
KunAnimationScene.prototype.capture = function(){
    return this._capture;
};
/**
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.captureFrom = function( x , y ){
    this._capture = [x , y];
    return this;
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.captureTo = function( x , y ){
    if( this._capture.length === 2 ){
        this._capture.push(x);
        this._capture.push(y);
        //sort and arrrange
        if( this._capture[0] > this._capture[2]){
            var mx = this._capture[0];
            this._capture[0] = this._capture[2];
            this._capture[2] = mx;
        }
        if( this._capture[1] > this._capture[3]){
            var my = this._capture[1];
            this._capture[1] = this._capture[3];
            this._capture[3] = my;
        }
        KunSceneManager.DebugLog( `Capture Coords: ${this._capture.join( ' ' )}` );
    }
    return this.clearCapture();
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.clearCapture = function(){
    this._capture = [];
    return this;
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.playing = function(){ return this._playing && this.current() !== null; }
/**
 * @param {Boolean} reset
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.stop = function( reset ){
    this._playing = false;
    return typeof reset === 'boolean' && reset ? this.reset( false ) : this;
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.resume = function(){
    this._playing = true;
    return this;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.getFrame = function(){
    return this.has(this._current) ? this._animationLayers[this._current].getFrame( this._index ) : 0;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.index = function(){ return this._index; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.cols = function(){ return this._cols; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.rows = function(){ return this._rows; }
/**
 * @returns Number
 */
KunAnimationScene.prototype.totalFrames = function(){ return this._cols * this._rows; };
/**
 * @param {String} fs 
 * @returns Boolean
 */
KunAnimationScene.prototype.has = function( fs ){ return fs.length > 0 && this._animationLayers.hasOwnProperty( fs ); }
/**
 * @param {KunAnimationLayer} layer 
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.add = function( layer ){
    if( layer instanceof KunAnimationLayer ){
        this._animationLayers[ layer.name() ] = layer;
        if( this._current.length === 0 ){
            this.changeLayer( layer.name());
        }
    }
    return this;
};
/**
 * @param {Number} fps 
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.setFps = function( fps ){
    switch( true ){
        case typeof fps === 'number' && fps > 0:
            this._fps = fps;
            break;
        case this.has(this._current):
            this._fps = this._animationLayers[this._current].fps();
            break;
        default:
            this._fps = KunSceneManager.defaultFps();
            break;
    }
    return this;
};
/**
 * @param {Boolean} list 
 * @returns KunAnimationLayer[] | Object
 */
KunAnimationScene.prototype.layers = function( list ){
    return typeof list === 'boolean' && list ? Object.values( this._animationLayers ) : this._animationLayers;
}
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.empty = function(){
    return this.layers(true).length === 0;
};
/**
 * @returns {Number}
 */
KunAnimationScene.prototype.countFrames = function(){
    return this.has(this._current) ? this.current().count() : 0;
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.beforeChangeLayer = function( ){
    var current = this.current();
    if( current !== null && current.clearTargetQueue()){
        //clear target queue on change from this scene to another
        KunSceneManager.clearTargets();
    }
    return this;
};
/**
 * @param {String} fs 
 * @param {Boolean} play
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.changeLayer = function( setName , play ){
    if( this.has( setName ) ){
        this.beforeChangeLayer();
        this._current = setName;
        return this.setFps().reset( typeof play === 'boolean' && play ).afterChangeLayer();
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.afterChangeLayer = function( ){
    return this;
};
/**
 * @param {Boolean} replay
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.next = function( replay ){
    var next = this.has(this._current) ? this.current().getNext() : '';
    if( next.length > 0 ){
        return this.changeLayer( next , true );
    }
    if( typeof replay === 'boolean' && replay ){
        //return this.changeLayer( this._current , true );
        return this.reset(true);
    }
    else{
        this._playing = false;
    }
    return this;
};
/**
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.first = function(){
    if(!this.empty()){
        return this.changeLayer(this.layers(true)[0].name(), true );
    }
    return this;
};
/**
 * @param {Boolean} play
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.reset = function( play ){
    this._loopCount = this.current().loops();
    switch(this.current().behavior()){
        case KunSceneManager.Behavior.Reverse:
            this._backwards = true;
            this._index = this.countFrames() - 1;
            break;
        case KunSceneManager.Behavior.Forward:
            this._backwards = false;
            break;
        case KunSceneManager.Behavior.PingPong:
            this._backwards = false;
            break;
        case KunSceneManager.Behavior.Static:
            break;
    }
    this._playing = (typeof play === 'boolean' && play ) || this._playing;
    if( this.playing() ){
        this.playBank( this._prefix );
    }
    return this;
}
/**
 * @param {Number} round
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.playBank = function( round ){
    if( this.playing() ){
        this.current().playBank( this._prefix , round );
    }
    return this;
};
/**
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.playBankByRound = function( loop ){
    if( this.playing() ){
        var bank = this.current().selectSoundBank();
        if( bank.length > 0 ){
            KunSceneManager.playBank( bank , loop );
        }
    }
    return this;
};
/**
 * @returns Number
 */
KunAnimationScene.prototype.FPS = function(){
    return this._fps;
};
/**
 * @returns Boolean
 */
KunAnimationScene.prototype.tick = function(){
    this._elapsed = ++this._elapsed % this.FPS();
    return this._elapsed === 0;
};
/**
 * @returns {KunAnimationScene}
 */
KunAnimationScene.prototype.update = function(){
    if( this.playing() ){
        //this._elapsed = ++this._elapsed % this.FPS();
        if( this.tick() ){
            switch( this.current().behavior() ){
                case KunSceneManager.Behavior.PingPong:
                    this.updatePingPong();
                    break;
                case KunSceneManager.Behavior.Reverse:
                    this.updateReverse();
                    break;
                case KunSceneManager.Behavior.Static:
                    //do not change
                    break;
                case KunSceneManager.Behavior.Forward:
                default:
                    this.updateForward();
                    break;
            }
            //this.changeLayer(KunSceneManager.getOverride(this._name));
    
            return true;
        }    
    }
    return false;
};
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.updatePingPong = function(){
    if( !this._backwards ){
        if( ++this._index >= this.countFrames() - 1 ){
            this._backwards = true;
        }
    }
    else if(this._index > 0){
        //reverse
        this._index--;
    }
    //after complete the round
    if( this._index === 0 && this._backwards ){
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playBankByRound(this._loopCount);
        }
        this._backwards = false;
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.updateReverse = function(){
    if( this._index > 0 ){
        this._index--;
    }
    else{
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playBankByRound(this._loopCount);
        }
        this._index = this.countFrames()-1;
    }
    return this;
}
/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.updateForward = function(){
    this._index = ( this._index + 1 ) % this.countFrames();
    if( this._index === 0 ){
        if( this._loopCount > 0 ){
            this._loopCount--;
            if( this._loopCount === 0 ){
                //change state
                return this.next(true);
            }
            this.playBankByRound(this._loopCount);
        }
        //this._index = 0;
    }
    return this;
}

/**
 * @returns KunAnimationScene
 */
KunAnimationScene.prototype.instance = function(){
    var copy = new KunAnimationScene( this._name, this._cols,this._rows , this._fps , this._prefix );
    copy._current = this._current;
    copy._frameSets = this._animationLayers;
    return copy.reset();
};
KunAnimationScene.prototype.dump = function(){
    return this;
};

/**
 * @returns 
 */
KunAnimationScene.INVALID = new KunAnimationScene('INVALID');


function KunAnimationLayer(){ this.initialize.apply( this , arguments ); };
//KunAnimationLayer.prototype = Object.create(Sprite.prototype);
/**
 * 
 * @param {String} name 
 * @param {String} type 
 * @param {Number} fps 
 * @param {Number} loops 
 * @param {String} next 
 * @param {String} bank
 * @param {Number} offsetX
 * @param {Number} offsetY
 */
KunAnimationLayer.prototype.initialize = function( name , type , fps, loops , next , bank , offsetX , offsetY , clearTargets ){
    this._name = name.toLowerCase().replace(/[\s\_]/,'-');
    this._fps = typeof fps === 'number' && fps > 0 ? fps : 0;
    this._frames = [];
    this._type = type || KunSceneManager.Behavior.Default;
    this._loops = loops || 0;
    this._offsetX = offsetX || 0;
    this._offsetY = offsetY || 0;
    this._clearTargets = typeof clearTargets === 'boolean' && clearTargets;
    this._spots = {
        //interactive spots to touch
    };
    this._next = Array.isArray( next ) ? next  : ( typeof next === 'string' && next.length ? [next] : [] );
    this._bank = Array.isArray(bank) ? bank : ( typeof bank === 'string' && bank.length ? [bank] : []) ;
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.clearTargetQueue = function( ){
    return this._clearTargets;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.offsetX = function( ){
    return this._offsetX;
    if( typeof scale !== 'number'){
        scale = 1;
    }
    return parseInt( this._offsetX * scale );
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.offsetY = function( ){
    return this._offsetY;
    if( typeof scale !== 'number'){
        scale = 1;
    }
    return parseInt( this._offsetY * scale );
};
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.isInteractive = function(){
    return this.spots(true).length > 0;
};
/**
 * 
 * @param {KunTouchEvent} spot 
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.registerSpot = function( spot ){

    if( spot instanceof KunTouchEvent && !this._spots.hasOwnProperty(spot.name()) ){
        //
        this._spots[spot.name()] = spot;
    }

    return this;
};
/**
 * List all spots as array or object ids
 * @param {Boolean} list 
 * @returns Object | KunTouchEvent[]
 */
KunAnimationLayer.prototype.spots = function( list ){
    return typeof list === 'boolean' && list ? Object.values( this._spots ) : this._spots;
}
/**
 * @param {String} spot 
 * @returns Boolean
 */
KunAnimationLayer.prototype.hasSpot = function( spot ){
    return this._spots.hasOwnProperty(spot);
}
/**
 * @param {String} spot 
 * @returns KunTouchEvent
 */
KunAnimationLayer.prototype.getSpot = function( spot ){
    return this.hasSpot(spot) ? this._spots[spot] : null;
}
/**
 * Check if any spot was touched
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent 
 */
KunAnimationLayer.prototype.touchSpot = function( x , y ){
    var hotspots = this.spots(true);
    for( var i in hotspots ){
        //hotspots[i].test( x , y );
        if( hotspots[i].touched( x , y ) ){
            //console.log( `${hotspots[i]} touched on ${x},${y}` );
            return hotspots[i];
        }
    }
    return null;
};
/**
 * @returns String
 */
KunAnimationLayer.prototype.behavior = function(){
    return this._type;
};
/**
 * @param {Number} frame 
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.add = function( frame ){
    this._frames.push( frame );
    return this;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.fps = function(){
    return this._fps > 0 ? this._fps : KunSceneManager.defaultFps();
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.loops = function(){
    return this._loops;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.frames = function( ){
    return this._frames.length > 0 ? this._frames : [0];
}
/**
 * @returns Number
 */
KunAnimationLayer.prototype.first = function(){
    return this.frames().length > 0 ? this.frames()[0] : 0;
};
/**
 * @param {Number} index 
 * @returns Number
 */
KunAnimationLayer.prototype.getFrame = function( index ){
    return this._frames.length > index ? this._frames[index] : this._frames[0];
    return this._frames.length > index ? this._frames[index] : 0;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.count = function(){
    return this.frames().length;
};
/**
 * @returns Number
 */
KunAnimationLayer.prototype.name = function(){
    return this._name;
};
/**
 * @returns String
 */
KunAnimationLayer.prototype.getNext = function(){
    var next = this._next.length > 1 ? Math.floor( Math.random() * this._next.length ) : 0;    
    return this._next.length > 0 ? this._next[ next ] : '';
}
/**
 * @returns Boolean
 */
KunAnimationLayer.prototype.hasSoundBank = function(){
    return this._bank.length > 0;
};
/**
 * @param {String} prefix
 * @returns String
 */
KunAnimationLayer.prototype.selectSoundBank = function( prefix ){
    if( this.hasSoundBank() ){
        var selection = this._bank.length > 1 ? Math.floor(Math.random() * this._bank.length) : 0;
        return typeof prefix === 'string' && prefix.length ? prefix + '-' + this._bank[selection] : this._bank[selection];
    }
    return '';
};
/**
 * @param {String} prefix
 * @param {Number} round
 * @returns KunAnimationLayer
 */
KunAnimationLayer.prototype.playBank = function( prefix , round ){
    KunSceneManager.playBank( this.selectSoundBank( prefix ) , round );
    return this;
};
/**
 * @returns KunAnimationLayer
 */
/*KunAnimationLayer.prototype.getSoundBank = function( ){
    return KunSceneManager.soundBank( this.selectSoundBank() );
};*/

/**
 * 
 * @param {String} name 
 * @param {Number} x1 
 * @param {Number} y1 
 * @param {Number} x2 
 * @param {Number} y2 
 * @param {Number} varId
 * @param {String} behavior
 * @param {String} sfx
 * @param {String} next
 */
function KunTouchEvent( name , x1 , y1 , x2 , y2 , varId , amount , behavior, trigger, sfx , next  ){

    this._name = name;
    this._x1 = parseInt( x1 );
    this._y1 = parseInt(y1);
    this._x2 = parseInt(x2);
    this._y2 = parseInt(y2);
    this._varId = parseInt(varId || 0 );
    this._amount = typeof amount === 'number' && amount > 0 ? amount : 1;
    this._behavior = typeof behavior === 'string' && behavior.length ? behavior : KunTouchEvent.Behaviour.Add;
    this._trigger = typeof trigger === 'string' && trigger.length ? trigger : KunTouchEvent.Trigger.Queue;
    this._sfx = sfx || '';
    this._next = next || [];

    this._hotspot = null;
}
/**
 * @returns String
 */
KunTouchEvent.prototype.toString = function(){
    return `${this.name()} (${this._x1} ${this._y1} ${this._x2} ${this._y2})`;
}
/**
 * @returns String
 */
KunTouchEvent.prototype.name = function(){
    return this._name;
};
/**
 * @param {Boolean} random 
 * @returns Number
 */
KunTouchEvent.prototype.getPosX = function( random ){
    return typeof random === 'boolean' && random ? this._x1 + Math.floor( Math.random() * (this._x2 - this._x1)) : this._x1;
};
/**
 * @param {Boolean} random 
 * @returns Number
 */
KunTouchEvent.prototype.getPosY = function( random ){
    return typeof random === 'boolean' && random ? this._y1 + Math.floor( Math.random() * (this._y2 - this._y1)) : this._y1;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.next = function(){
    var jumpTo = this._next.length > 1 ? Math.floor( Math.random() * this._next.length) : 0;
    return this._next.length > 0 ? this._next[ jumpTo ] : '';
};
/**
 * @returns Number
 */
KunTouchEvent.prototype.amount = function(){
    return this._amount;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.behavior = function(){
    return this._behavior;
};
/**
 * @returns String
 */
KunTouchEvent.prototype.trigger = function(){
    return this._trigger;
};
/**
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.touchSfx = function(){
    if( this._sfx.length ){
        KunSceneManager.PlayFX( this._sfx );
    }
    return this;
}
KunTouchEvent.prototype.setValue = function( value ){
    if( this._varId > 0 ){
        $gameVariables.setValue( this._varId , value );
    }
    return this;
};
/**
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.update = function(){
    if( this._varId > 0 ){
        switch( this.behavior()){
            case KunTouchEvent.Behaviour.Add:
            case KunTouchEvent.Behaviour.Increase: //deprecated
                this.setValue( $gameVariables.value(this._varId) + this.amount() );
                break;
            case KunTouchEvent.Behaviour.Substract:
                var amount = $gameVariables.value(this._varId) - this._amount();
                this.setValue( amount > 0 ? amount : 0 );
                break;
            case KunTouchEvent.Behaviour.Set:
                this.setValue( this.amount() );
                break;
            //case KunTouchEvent.Behaviour.Frame:
                //this.setValue( $gameVariables.value(this._varId) + 1 );
            //    break;
        }
    }
    return this;
}
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns 
 */
KunTouchEvent.prototype.touched = function( x , y ){
    return (this._x1 <= x && this._x2 >= x) && (this._y1 <= y && this._y2 >= y);
};
/**
 * 
 * @param {Number} x 
 * @param {Number} y 
 * @returns KunTouchEvent
 */
KunTouchEvent.prototype.test = function( x , y){
    KunSceneManager.DebugLog( `${this.name()} X(${this._x1} >= ${x} <= ${this._x2}) Y(${this._y1} >= ${y} <= ${this._y2})` );
    return this;
};
/**
 * 
 */
KunTouchEvent.Trigger = {
    'Instant': 'instant',
    'Queue': 'queue',
    'Ignore': 'ignore',
    'Frame': 'frame',
};
/**
 * 
 */
KunTouchEvent.Behaviour = {
    'Increase': 'increase',
    'Add': 'add',
    'Substract': 'sub',
    'Set': 'set',
    'Frame': 'frame', //DEPRECATED
};


/**
 * @param {String} name 
 * @param {Number} chance
 * @param {Boolean} interrupt
 * @param {Number} round
 */
/*function KunSoundBank( name , chance , interrupt , round ){
    this._name = name || '';
    this._chance = chance || 100;
    this._interrupt = typeof interrupt === 'boolean' && interrupt;
    this._se = [];
    this._volume = [];
    this._pitch = [];
    this._pan = [];
    this._round = round || 0;
};*/
/**
 * @returns String
 */
/*KunSoundBank.prototype.toString = function(){
    return this.name();
};*/
/**
 * @returns String
 */
/*KunSoundBank.prototype.name = function(){
    return this._name;
};*/
/**
 * @returns Number
 */
/*KunSoundBank.prototype.round = function(){
    return this._round;
};*/
/**
 * @returns Boolean
 */
/*KunSoundBank.prototype.interrupt = function(){
    return this._interrupt && !KunSceneManager.canInterrupt();
};*/
/**
 * @returns Number
 */
/*KunSoundBank.prototype.chance = function( ){
    return this._chance > Math.floor( Math.random() * 100 );
};*/
/**
 * 
 * @param {String} se 
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.addSe = function( se ){
    if( typeof se === 'string' && se.length ){
        this._se.push( se );
    }
    return this;
};*/
/**
 * @param {Number} vol 
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.addVol = function( vol ){
    if( typeof vol === 'number' && vol ){
        this._volume.push(vol);
    }
    return this;
};*/
/**
 * @param {Number} pitch 
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.addPitch = function( pitch ){
    if( typeof pitch === 'number' && pitch ){
        this._pitch.push(pitch);
    }
    return this;
};*/
/**
 * @param {Number} pan 
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.addPan = function( pan ){
    if( typeof pan === 'number' && pan ){
        this._pan.push(pan);
    }
    return this;
};*/
/**
 * @returns Number
 */
/*KunSoundBank.prototype.pan = function(){
    switch( this._pan.length ){
        case 0: return 0;
        case 1: return this._pan[0];
        case 2:
            var min = this._pan[0] < this._pan[1] ? this._pan[0] : this._pan[1];
            var max = this._pan[1] > this._pan[0] ? this._pan[1] : this._pan[0];
            return min + Math.floor(Math.random() * (max - min ));
        default:
            return this._pan[ Math.floor(Math.random() * this._pan.length) ];
    }
};*/
/**
 * @returns Number
 */
/*KunSoundBank.prototype.pitch = function(){
    switch( this._pitch.length ){
        case 0: return 100;
        case 1: return this._pitch[0];
        case 2:
            var min = this._pitch[0] < this._pitch[1] ? this._pitch[0] : this._pitch[1];
            var max = this._pitch[1] > this._pitch[0] ? this._pitch[1] : this._pitch[0];
            return min + Math.floor(Math.random() * (max - min ));
        default:
            return this._pitch[ Math.floor(Math.random() * this._pitch.length) ];
    }
};*/
/**
 * @returns Number
 */
/*KunSoundBank.prototype.volume = function(){
    switch( this._volume.length ){
        case 0: return 50;
        case 1: return this._volume[0];
        case 2:
            var min = this._volume[0] < this._volume[1] ? this._volume[0] : this._volume[1];
            var max = this._volume[1] > this._volume[0] ? this._volume[1] : this._volume[0];
            return min + Math.floor(Math.random() * (max - min ));
        default:
            return this._volume[ Math.floor(Math.random() * this._volume.length) ];
    }
};*/
/**
 * @returns String
 */
/*KunSoundBank.prototype.select = function(){
    switch( this._se.length ){
        case 0: return '';
        case 1: return this._se[0];
        default: return this._se[ Math.floor(Math.random() * this._se.length)];
    }
};*/
/**
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.play = function(){
    if( this.canPlay() && this.chance() ){
        var selection = this.select();
        if( selection.length ){
            KunSceneManager.AudioManager( selection, this.volume(), this.pitch() , this.pan() , this.interrupt());
        }    
    }
    return this;
};*/
/**
 * @returns KunSoundBank
 */
/*KunSoundBank.prototype.playRound = function( round ){
    if( this.canPlay() && this.round() > 0 && round % this.round() === 0 ){
        this.play();
    }
    return this;
};*/
/**
 * @returns Boolean
 */
/*KunSoundBank.prototype.canPlay = function(){
    return this._se.length > 0;
};*/
/**
 * 
 * @returns KunSoundBank
 */
/*KunSoundBank.Empty = function(){
    return new KunSoundBank('EMPTY');
};*/


/**
 * 
 */
function KunAnimations_RegisterManagers(){

    var _kunAnimations_Initialize_Sprite = Sprite_Picture.prototype.initialize;
    Sprite_Picture.prototype.initialize = function( pictureId ){
        _kunAnimations_Initialize_Sprite.call(this,pictureId);
        this._touching = false;
    };

    var _kunAnimations_Load_Bitmap = Sprite_Picture.prototype.loadBitmap;
    Sprite_Picture.prototype.loadBitmap = function() {
        //vanilla image preload
        _kunAnimations_Load_Bitmap.call(this);
        //setup animation if its a scene spritesheet
        if( this.isAnimated() ){
            this.animationScene().reset(true); //initialize and play
            this.bitmap.addLoadListener(this.initializeAnimation.bind(this));
        }
    };

    var _kunAnimations_Update_Sprite = Sprite_Picture.prototype.update;
    Sprite_Picture.prototype.update = function(){
        //call vanilla
        _kunAnimations_Update_Sprite.call( this );

        if( this.isAnimated()){
            //update the scene manager
            this.updateAnimation( this.animationScene( ) ).processTouch();
        }
    };
    /**
     * @returns Sprite_Picture
     */
    Sprite_Picture.prototype.initializeAnimation = function( ){
        return this.updateAnimation( this.animationScene( ) , true );
    };
    /**
     * @param {KunAnimationScene} sceneController
     * @param {Boolean} forceUpdate
     * @returns Sprite_Picture
     */
    Sprite_Picture.prototype.updateAnimation = function( sceneController , forceUpdate ){
        if( sceneController.isValid() ){
            if( sceneController.update() || forceUpdate ){
                var index = sceneController.getFrame();
                var w = this.bitmap.width / sceneController.cols();
                var h = this.bitmap.height / sceneController.rows();
                var x = index % sceneController.cols() * w;
                var y = Math.floor(index / sceneController.cols()) * h;
                this.setFrame( x, y, w, h);
                //return true;                    
            }
        }
        return this;
    };
    /**
     * @returns KunAnimationScene
     */
    Sprite_Picture.prototype.animationScene = function(){
        return KunSceneManager.scene(this._pictureName);
    };
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.isAnimated = function(){
        return KunSceneManager.has(this._pictureName);
    }
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.isLoaded = function(){
        return typeof this.bitmap !== 'undefined' && this.bitmap !== null;
    };

    Sprite_Picture.prototype.isInteractive = function(){
        //capture from plugin animation data
        return this.animationScene().isInteractive();
    };
    /**
     * @param {Number} x 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetX = function( x ){
        return this.picture().scaleX() > 0 ? Math.floor((x - this.picture().x()) * 100 / this.picture().scaleX()) : 0;
    };
    /**
     * @param {Number} y 
     * @returns Number
     */
    Sprite_Picture.prototype.offsetY = function( y ){
        return this.picture().scaleY() > 0 ? Math.floor((y - this.picture().y()) * 100 / this.picture().scaleY()) : 0;
    };
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.validScale = function(  ){
        return this.picture().scaleX() > 0 && this.picture().scaleY() > 0
    }
    /**
     * @returns Boolean
     */
    Sprite_Picture.prototype.processTouch = function() {
        if( this.isAnimated() ){
            if (TouchInput.isTriggered()) {
                if( !this._touching ){
                    this._touching = true;
                }
                if(KunSceneManager.canCapture()){
                    this.animationScene().captureFrom( this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));
                }
            }
            if (TouchInput.isReleased()) {
                if (this._touching) {
                    this._touching = false;
                    //console.log( `Touch ${TouchInput._x},${TouchInput._y} (${this.validScale()})` );
                    //var picture = this.picture();
                    if(KunSceneManager.canCapture()){
                        this.animationScene().captureTo(this.offsetX(TouchInput._x), this.offsetY(TouchInput._y));    
                    }
                    else if( KunSceneManager.canTouch() && this.validScale( ) ){
                        var X = TouchInput._x;
                        var Y = TouchInput._y;
                        this.animationScene().touch(this.offsetX(X), this.offsetY(Y), X, Y);
                    }
                }
            }
        }
        return this._touching;
    };

    //OVERRIDE Game_Picture move method to capture the picture offset when required
    var _kunAnimations_Game_Picture_Move = Game_Picture.prototype.move;
    Game_Picture.prototype.move = function(origin, x, y, scaleX, scaleY, opacity, blendMode, duration) {

        //capture X and Y offset from picture name
        if( this._name.length ){
            //import offset from currently active picture's frameset controller plus the scale
            var _offset = KunSceneManager.offset(this._name);
            //then apply the transformations
            x -= parseInt( _offset.x * (scaleX / 100) );
            y -= parseInt( _offset.y * (scaleY / 100) );
        }

        _kunAnimations_Game_Picture_Move.call(this,origin,x,y,scaleX,scaleY,opacity,blendMode,duration);
    };
    /**
     * 
     * @param {String} picture 
     * @param {Number} x 
     * @param {Number} y 
     */
    Game_Screen.prototype.exportPosition = function( picture, x , y ){
        var screenPic = this._pictures.filter( gp => gp !== null && gp._name === picture );
        if( screenPic.length > 0 ){
            KunSceneManager.DebugLog( `${x} , ${y}` );
            var px = screenPic[0]._x + Math.floor( screenPic[0]._scaleX / 100  * x );
            var py = screenPic[0]._y + Math.floor( screenPic[0]._scaleY / 100  * y );
            KunSceneManager.DebugLog( `${picture}: ${px},${py} (${screenPic[0]._x},${screenPic[0]._y})` );
            KunSceneManager.exportPosition( px , py );
        }
    };
}
/**
 * 
 */
function KunAnimations_SetupCommands(){
    var _KunAnimations_SetupCommands = Game_Interpreter.prototype.pluginCommand;
    Game_Interpreter.prototype.pluginCommand = function(command, args) {
        _KunAnimations_SetupCommands.call(this, command, args);
        if (command === 'KunAnimations' && args.length > 0 ) {
            switch( args[0] ){
                case 'alias':
                    if( args.length > 2 ){
                        KunSceneManager.setAlias( args[1] , args[2] );
                    }
                    break;
                case 'prepare':
                case 'complete':
                    //clear all referenecs before starting scene
                    KunSceneManager.clearAlias().clearTargets().clearPlaying();
                    break;
                case 'clear':
                    if( args.length > 1 ){
                        switch( args[1]){
                            case 'targets':
                                KunSceneManager.clearTargets();
                                break;
                            case 'alias':
                                KunSceneManager.clearAlias();
                                break;
                            case 'scenes':
                                KunSceneManager.clearPlaying();
                                break;
                            case 'all':
                                KunSceneManager.clearAlias().clearTargets().clearPlaying();
                                break;
                        }
                    }
                    else{
                        KunSceneManager.clearTargets();
                    }
                    break;
                case 'fps':
                    if( args.length > 2 ){
                        var fps = parseInt( args[2] );
                        if( args.length > 3 && args[3] === 'import' ){
                            fps = $gameVariables.value( fps );
                        }
                        KunSceneManager.overrideFPS( KunSceneManager.getAlias(args[1]) ,  fps );
                        //KunSceneManager.DebugLog(`FPS updated to ${fps}`);
                    }
                    break;
                case 'reset':
                    if( args.length > 1 ){
                        KunSceneManager.reset( KunSceneManager.getAlias(args[1]) , args.length > 2 && args[2] === 'replay' );
                    }
                    break;
                case 'set':
                    if( args.length > 2 ){
                        var frameSet = args[2].replace(/\./g,':').split(':');
                        //var frameSet = args[2].split('.');
                        var selection = frameSet.length > 1 ? frameSet[ Math.floor( Math.random() * frameSet.length ) ] : frameSet[0];
                        var name = KunSceneManager.getAlias(args[1]);
                        KunSceneManager.playScene( name , selection );
                        if( args.length > 3 && args[3] === 'wait'){
                            if ( args.length > 4 ){
                                var wait = args[4].split(':').map( count => parseInt(count));
                                this.wait( wait.length > 1 ? wait[0] + Math.floor( Math.random() * ( wait[1] - wait[0] ) ) : wait[0] );
                            }
                        }
                        if( args.length > 4 && args[3] === 'spot' ){
                            var spots = args[4].split(':');
                            KunSceneManager.captureSpot( name ,
                                spots.length > 1 ? spots[Math.floor(Math.random()*spots.length)] : spots[0] );
                        }
                    }
                    break;
                case 'pause':
                    if( args.length > 1 ){
                        KunSceneManager.stop( KunSceneManager.getAlias(args[1]) , args.length > 2 && args[2] === 'reset' );
                    }
                    break;
                case 'resume':
                    if( args.length > 1 ){
                        KunSceneManager.resume( KunSceneManager.getAlias(args[1]) );
                    }
                    break;
                case 'wait':
                    if( args.length > 1 ){
                        var wait = args[1].split(':').map( t => parseInt(t));
                        if( args.length > 2 && args[2] === 'import' && wait > 0 ){
                            wait[0] = $gameVariables.value( wait[0] );
                            if( wait.length > 1 ){
                                wait[1] = $gameVariables.value(wait[1]);
                            }
                        }
                        this.wait( wait.length > 1 ? wait[0] + Math.floor(Math.random() * wait[1]) : wait[0] );
                        KunSceneManager.DebugLog(`Waiting ${wait[0]} +(${wait.length > 1 ? wait[1] : 0}) fps ...`);
                    }
                    break;
                case 'spot':
                    if( args.length > 2 ){
                        var selection = args[2].split(':');
                        KunSceneManager.captureSpot(
                            KunSceneManager.getAlias( args[1]) ,
                            selection.length > 1 ? selection[Math.floor(Math.random()*selection.length)] : selection[0] );
                    }
                    break;
                case 'target':
                    if( args.length > 1 ){
                        if( args[1] === 'random' ){
                            KunSceneManager.target(true);
                        }
                        else if( args.length > 2 ){
                            var selection = args[2].split(':');
                            KunSceneManager.captureSpot(
                                KunSceneManager.getAlias( args[1]) ,
                                selection.length > 1 ? selection[Math.floor(Math.random()*selection.length)] : selection[0] );    
                        }
                    }
                    else{
                        KunSceneManager.target( );
                    }
                    //KunSceneManager.target(args.length > 1 && args[1] === 'random');
                    break;
                case 'interruption':
                    if( args.length > 1 ){
                        KunSceneManager.stopInterruption( args[1].toLowerCase() === 'on' );
                    }
                    else{
                        KunSceneManager.stopInterruption( false );
                    }
                    break;
                case 'mode':
                    KunSceneManager.setMode( args.length > 1  ? args[1] : KunSceneManager.Mode().Disabled );
                    if( KunSceneManager.canCapture() ){
                        KunSceneManager.DebugLog(`Capture Mode ON. Click and drag over a picture spot, then release to define the target area.`);
                    }
                    else{
                        KunSceneManager.DebugLog(`${KunSceneManager.mode()} mode on`);
                    }
                    break;
                case 'list':
                    KunSceneManager.list();
                    break;
            }
        }
    };

}

/********************************************************************************************************************
 * 
 * INITIALIZER
 * 
 *******************************************************************************************************************/

 (function( /* args */ ){

    KunSceneManager.Initialize();

    KunAnimations_RegisterManagers();

    KunAnimations_SetupCommands();
})( /* initializer */ );



